\documentclass[a4paper]{article}

\usepackage[dutch]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{parskip}
\usepackage{array}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,calc,fit,positioning}
\usepackage{chngcntr}
\counterwithin{figure}{section}

\begingroup
    \makeatletter
    \@for\theoremstyle:=definition,remark,plain\do{%
        \expandafter\g@addto@macro\csname th@\theoremstyle\endcsname{%
            \addtolength\thm@preskip\parskip
            }%
        }
\endgroup

\newcommand\addvmargin[1]{
  \node[fit=(current bounding box),inner ysep=#1,inner xsep=0]{};
}

\definecolor{silver}{rgb}{0.95,0.95,0.95}

\newtheorem{tdefinitie}{Definitie}[section]
\newenvironment{definitie}[1]%
  {\begin{mdframed}[backgroundcolor=silver,
    topline=false,
    rightline=false,
    leftline=false,
    bottomline=false]\begin{tdefinitie}#1\\\normalfont}%
  {\end{tdefinitie}\end{mdframed}}

\newtheorem{talgo}{Algoritme}[section]
\newenvironment{algoritme}[1]%
  {\begin{mdframed}[backgroundcolor=silver,
    topline=false,
    rightline=false,
    leftline=false,
    bottomline=false]\begin{talgo}#1\\\normalfont}%
  {\end{talgo}\end{mdframed}}
  
\renewcommand{\qedsymbol}{$\blacksquare$}
\newenvironment{bewijs}%
  {\begin{mdframed}[topline=true,
    rightline=true,
    leftline=true,
    bottomline=true]\begin{proof}[Bewijs]\normalfont}%
  {\end{proof}\end{mdframed}}
 
\newenvironment{nfa}%
  {\begin{tikzpicture}[->,
    >=stealth',
    shorten >=1pt,
    auto,
    node distance=2cm,
    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]
  \tikzstyle{accepting}=[accepting by double]
  \tikzstyle{every initial by arrow}=[initial text=]}%
  {\end{tikzpicture}}
 
\newenvironment{pda}%
  {\begin{tikzpicture}[->,
    >=stealth',
    shorten >=1pt,
    auto,
    node distance=2cm,
    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]
  \tikzstyle{accepting}=[accepting by double]
  \tikzstyle{every initial by arrow}=[initial text=]}%
  {\end{tikzpicture}}
  
\newenvironment{enumalgo}%
  {\begin{enumerate}[leftmargin=1.5cm,label=Stap \arabic*:]}%
  {\end{enumerate}}
  
\newenvironment{nobreakparagraph}%
  {\par\nobreak\vfil\penalty0\vfilneg\vtop\bgroup}%
  {\par\xdef\tpd{\the\prevdepth}\egroup\prevdepth=\tpd}%
  
\newcommand{\powerset}{\ensuremath{\mathcal{P}}}
\newcommand{\partition}{\ensuremath{\mathfrak{P}}}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\dfastate}{\ensuremath{\mathcal{Q}}}
\newcommand{\en}{\ensuremath{\text{ en }}}
\newcommand{\of}{\ensuremath{\text{ of }}}
\newcommand{\sstar}{\ensuremath{\Sigma^*}}

\begin{document}

\begin{titlepage}
    \newpage
    \thispagestyle{empty}
    \frenchspacing
    \hspace{-0.2cm}
    \includegraphics[height=3.4cm]{assets/sedes}
    \hspace{0.2cm}
    \rule{0.5pt}{3.4cm}
    \hspace{0.2cm}
    \begin{minipage}[b]{8cm}
        \large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
        \large{}\smallskip\newline
        \textbf{Department \newline Computerwetenschappen}\smallskip
    \end{minipage}
    \hspace{\stretch{1}}
    \vspace*{3.2cm}\vfill
    \begin{center}
        \begin{minipage}[t]{\textwidth}
            \begin{center}
                \large{\rm{\textbf{\uppercase{Samenvatting}}}}\\
                \large{\rm{Automaten en Berekenbaarheid [G0P84a]}}
            \end{center}
        \end{minipage}
    \end{center}
    \vfill
    \hfill\makebox[3cm][l]{%
        \vbox to 7cm{\vfill\noindent
            {\rm \textbf{Fr\'ed\'eric Hannes}}\\[2mm]
            {\rm Academisch jaar 2015--2016}
        }
    }
\end{titlepage}

\tableofcontents

\newpage

\section{Voorkennis}

\subsection{Belangrijke afkortingen}

\begin{tabular}{l|l}
	alss & Als en alleen als ($\Leftrightarrow$) \\
\end{tabular}

\subsection{Wiskundige symbolen}

\begin{tabular}{l|l}
	$\vee$ & Supremum \\
	$\wedge$ & Infimum \\
	$\triangleq$ & Is per definitie gelijk aan \\
\end{tabular}

\subsection{Griekse letters}

\begin{tabular}{l|l|l}
	Alpha & $\alpha$ & \\
	Beta & $\beta$ & \\
	Delta & $\delta$ & $\Delta$ \\
	Epsilon & $\varepsilon, \epsilon$ & \\
	Gamma & $\gamma$ & $\Gamma$ \\
	Mu & $\mu$ & \\
	Omega & $\omega$ & $\Omega$ \\
	Phi & $\varphi, \phi$ & $\Phi$ \\
	Rho & $\rho$ & \\
	Sigma & $\sigma$ & $\Sigma$ \\
	Tau & $\tau$ & \\
	Theta & $\theta$ & $\Theta$ \\
	Xi & $\xi$ & $\Xi$ \\
\end{tabular}

\subsection{Verzamelingenleer}

\begin{definitie}{Een algebra van een verzameling S}
Een algebra is een verzameling met daarop een aantal inwendige operaties.
\end{definitie}

\begin{definitie}{De unie van twee verzamelingen}
  De unie van twee verzamelingen $S_1$ en $S_2$ is de verzameling die alle elementen bevat die in $S_1$ en/of $S_2$ zitten. \\
  \\ $S_1 \cup S_2 = \{x|x \in S_1 \of x \in S_2\}$
\end{definitie}

\begin{definitie}{De doorsnede van twee verzamelingen}
  De doorsnede van twee verzamelingen $S_1$ en $S_2$ is de verzameling die alle elementen bevat die in zowel $S_1$ als $S_2$ zitten. \\
  \\ $S_1 \cup S_2 = \{x|x \in S_1 \en x \in S_2\}$
\end{definitie}

\begin{definitie}{Het complement van een verzameling}
  Het complement van een verzameling $S$ van alle elementen uit het domein die niet in $S$ zitten. \\
  \\ $\overline{S} = \{x|x \notin S\}$
\end{definitie}

\begin{definitie}{Een machtsverzameling $\powerset(S)$ van een verzameling $S$}
  Een machtsverzameling $\powerset(S)$ is een verzameling van alle deelverzamelingen die gevormd kunnen worden met de elementen in S, inclusief de lege verzameling en de verzameling A.\\ \\ $\powerset(S) = \{A|A \subseteq S\}$
\end{definitie}

\begin{definitie}{Een equivalentierelatie $\sim$ op een verzameling $S$}
  Een equivalentierelatie ($\sim$) is een relatie die de elementen van een verzameling groepeert die allemaal voldoen aan een zekere set criteria. Elke equivalentierelatie is
  \begin{itemize}
  \item reflexief: $\forall x \in S: x \sim x$
  \item symmetrisch: $\forall x, y \in S: x \sim y \Leftrightarrow y \sim x$
  \item transitief: $\forall x, y, z \in S: x \sim y \en y \sim z \Rightarrow x \sim z$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een equivalentieklasse onder $\sim$ op een verzameling $S$}
  Een equivalentieklasse ($x_\sim \subseteq S$) is de verzameling van alle elementen in de verzameling $S$ die onder de gegeven equivalentierelatie gelijkwaardig zijn aan $x$. \\
  \\ $x_\sim = \{y \in S|x \sim y\}$
\end{definitie}

\begin{definitie}{Een partitie $\partition$ van een verzameling $S$}
  Een partitie van een verzameling is een opdeling van de elementen van die verzameling in niet-lege onderling disjuncte delen. Als $\partition$ een partitie is van een verzameling $S$, dan geldt:
  \begin{itemize}
  \item $\emptyset \notin \partition$
  \item $\forall X, Y \in \partition: X \neq Y \Rightarrow X \cap Y = \emptyset$
  \item $\bigcup_{X \in \partition} = S$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een tralie ($L$, $\leq$, $\vee$, $\wedge$)}
  Een tralie is een partieel-geordende verzameling, geordend volgens $\leq$, met een supremum ($\vee$) en een infimum ($\wedge$) voor elk paar elementen. Voor een tralie geldt:
  \begin{itemize}
  \item $\forall x, y \in L: x \leq y \Rightarrow x = x \wedge y$
  \item $\forall x, y \in L: x \leq y \Rightarrow y = x \vee y$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een volledige tralie ($L$, $\leq$, $\vee$, $\wedge$)}
  Een tralie is een volledige tralie indien elke deelverzameling van $L$ een bovengrens en ondergrens heeft die een elementen zijn van $L$. \\
  \\ $\forall X \subseteq L: \bigwedge_X \in L \en \bigvee_X \in L$
\end{definitie}

\newpage\section{Talen}

\begin{definitie}{Een alfabet $\Sigma$}
  Een verzameling van symbolen.
\end{definitie}

\begin{definitie}{Een string $s$ over een alfabet $\Sigma$}
  Een opeenvolging nul, \'e\'en of meerdere elementen uit $\Sigma$. \\
  \\ $s = a_1a_2a_3...a_n$ met $a_i \in \Sigma, n \in \nat$
  \\ $s \in L$
\end{definitie}

\begin{definitie}{De lege string $\epsilon$ over een alfabet $\Sigma$}
  De lege string is een string die bestaat uit nul elementen.
\end{definitie}

\begin{definitie}{Het alfabet $\Sigma_\epsilon$}
  $\Sigma_\epsilon = \Sigma \cup \{\epsilon\}$
\end{definitie}

\begin{definitie}{Een taal $L$ over een alfabet $\Sigma$}
  Een verzameling van strings over $\Sigma$.\\
  \\ $L \subseteq \sstar$
  \\ $L \in L_\Sigma$
\end{definitie}

\begin{definitie}{Concatenatie van twee talen}
  $L_1L_2$ is de concatenatie van twee talen $L_1$ en $L_2$ over hetzelfde alfabet $\Sigma$. \\
  \\ $L_1L_2 = \{xy|x \in L_1, y \in L_2\}$
  \\ $L^n = \{x_1x_2x_3...x_n|x_i \in L, n \in \nat\}$
  \\ $L^0 = \{\epsilon\}$
\end{definitie}

\begin{definitie}{De Kleene ster $L^*$ van een taal $L$}
  $L^* = \bigcup^\infty_{n=0}L^n$
  \\ $L^+ = LL^*$
\end{definitie}

\begin{definitie}{De verzameling $\sstar$ van alle strings over $\Sigma$}
  $\sstar$ is een verzameling met alle strings die gevormd kunnen worden uit het alfabet $\Sigma$. Elke taal over $\Sigma$ is een deelverzameling van $\sstar$. \\
  \\ $\sstar = \{a_1a_2a_3...a_n|a_i \in \Sigma, n \in \nat\}$
\end{definitie}

\begin{definitie}{De verzameling $L_\Sigma$ van alle talen over $\Sigma$}
  $L_\Sigma = \powerset(\sstar)$ is een verzameling met alle talen die gevormd kunnen worden uit het alfabet $\Sigma$. Elke taal over $\Sigma$ is een element van $\powerset(\sstar)$.
\end{definitie}

De verzameling $L_\Sigma$ vormt een algebra met verschillende inwendige operaties, waaronder:
\begin{itemize}
\item Unie: $L_1 \cup L_2 \in L_\Sigma$ met $L_1 \in L_\Sigma, L_2 \in L_\Sigma$
\item Doorsnede: $L_1 \cap L_2 \in L_\Sigma$ met $L_1 \in L_\Sigma, L_2 \in L_\Sigma$
\item Complement: $\overline{L} \in L_\Sigma$ met $L \in L_\Sigma$
\item Concatenatie: $L_1L_2 \in L_\Sigma$ met $L_1 \in L_\Sigma, L_2 \in L_\Sigma$
\item Willekeurig lange concatenatie: $L_1^* \in L_\Sigma$ met $L_1 \in L_\Sigma$
\end{itemize}

\newpage\section{Reguliere talen}

\begin{definitie}{Een reguliere expressie $E$ over een alfabet $\Sigma$}
  $E$ is een reguliere expressie over $\Sigma$ indien $E$ van de vorm is:
  \begin{itemize}
  \item $\epsilon$ (lege string)
  \item $\phi$
  \item $a$ met $a \in \Sigma$
  \item $(E_1E_2)$ met $E_1$ en $E_2$ reguliere expressies over $\Sigma$
  \item $(E_1)^*$ met $E_1$ een reguliere expressie over $\Sigma$
  \item $(E_1|E_2)$ met $E_1$ en $E_2$ reguliere expressies over $\Sigma$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een reguliere expressie $E$ over een alfabet $\Sigma$ bepaalt een taal $L_E$ over $\Sigma$}
  Een taal bepaalt door een reguliere expressie is een reguliere taal.
  \begin{itemize}
  \item Als $E = \epsilon$, dan $L_E = \{\epsilon\}$
  \item Als $E = \phi$, dan $L_E = \emptyset$
  \item Als $E = a$ met $a \in \Sigma$, dan $L_E = \{a\}$
  \item Als $E = (E_1E_2)$, dan $L_E = L_{E_1}L_{E_2}$
  \item Als $E = (E_1)^*$, dan $L_E = L_{E_1}^*$
  \item Als $E = (E_1|E_2)$, dan $L_E = L_{E_1} \cup L_{E_2}$
  \end{itemize}
\end{definitie}

\begin{definitie}{De verzameling $RegLan$ van de reguliere talen}
  $RegLan$ is een verzameling die alle reguliere talen bevat. \\
  \\ $RegLan \subseteq L_\Sigma$
  \\ $x \in RegLan \Rightarrow x \in L_\Sigma$
  \\ $x \in RegLan \en y \in x \Rightarrow y \in \sstar$
\end{definitie}

% TODO (Optional): Bewijs dat RegLan een subalgebra is van L_Sigma

\subsection{NFA}

\begin{definitie}{Een niet-deterministische eindige toestandsautomaat}
  Een niet-deterministische eindige toestandsautomaat (NFA) is een 5-tal ($Q$, $\Sigma$, $\delta$, $q_s$, $F$):
  \begin{itemize}
  \item $Q$ is een eindige verzameling toestanden
  \item $\Sigma$ is een eindig alfabet
  \item \bm{$\delta : Q \times \Sigma_\epsilon \rightarrow \powerset(Q)$}\\$\delta$ is de overgangsfunctie
  \item $q_s \in Q$ is de starttoestand
  \item $F \subseteq Q$ is de verzameling van eindtoestanden
  \end{itemize}
\end{definitie}

Eigenschappen van een NFA:
\begin{itemize}
\item Een NFA is een gerichte graaf.
\item Elke knoop van een NFA heeft een label.
\item Knopen met een dubbele cirkel zijn eindtoestanden.
\item Lussen (bogen van een knoop naar zichzelf) zijn toegestaan in een NFA.
\item Boven van een NFA dragen een label met \'e\'en of meerdere symbolen uit het alfabet, gescheiden door een komma en/of $\epsilon$.
\item Er komt slechts \'e\'en boog aan in de starttoestand, die niet vertrekt vanuit een knoop.
\end{itemize}

% TODO: Uitvoering NFA
% TODO: Algebra van NFA's beschrijven

\begin{definitie}{Een string $s$ wordt aanvaard door een NFA}
  Een string $s$ ($a_1a_2a_3...a_n$ met $a_i \in \Sigma_\epsilon$) wordt aanvaard door een NFA ($Q$, $\Sigma$, $\delta$, $q_s$, $F$) als een rij toestanden $t_1t_2t_3...t_{n+1}$ bestaat zodanig dat:
  \begin{itemize}
  \item $t_1 = q_s$
  \item $t_{i+1} \in \delta(t_i, a_i)$
  \item $t_{n+1} \in F$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een taal bepaald door een NFA $M$}
  Een taal $L$ wordt bepaald door een NFA $M$ als $M$ elke string van $L$ aanvaardt. Deze taal noteren we als $L_M$.
\end{definitie}

\begin{definitie}{Equivalente NFA's}
  Twee NFA's zijn equivalent als ze dezelfde taal bepalen.
\end{definitie}

% TODO: Transitietabel

Elke NFA beschrijft een reguliere taal en elke reguliere taal kan beschreven worden door een NFA ($L_E = L_{NFA_E}$). Figuur \ref{fig:regexnfa} toont de overgangen van de elementaire reguliere expressies naar de bijhorende NFA's.

\begin{figure}[ht]
\label{fig:regexnfa}
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{10cm}}
$E$ & $NFA_E$ \\ \hline
$\epsilon$ & \begin{nfa}
  \node[initial,state,accepting] (A) {};
  \addvmargin{1mm}
\end{nfa} \\
$\phi$ & \begin{nfa}
  \node[initial,state] (A) {};
  \addvmargin{1mm}
\end{nfa} \\
$a \in \Sigma$ & \begin{nfa}
  \node[initial,state]   (A)              {};
  \node[state,accepting] (B) [right of=A] {};
  \path (A) edge [] node {$a$} (B);
  \addvmargin{1mm}
\end{nfa} \\
$(E_1|E_2)$ & \begin{nfa}
  \node[initial,state]   (A)                    []                                     {};
  \node[]                (B)                    [above right=.25cm and .5cm of A,draw] {$NFA_1$};
  \node                  (C)                    [below right=.25cm and .5cm of A,draw] {$NFA_2$};
  \node[state]           (D)                    [right of=B]                           {};
  \node[state]           (E)                    [right of=C]                           {};
  \node[state,accepting] (F) at ($(C)!0.5!(D)$) [right=3.7cm of A]                     {};
  
  \path (A) edge [bend left]  node               {$\epsilon$} (B)
            edge [bend right] node [below left]  {$\epsilon$} (C)
        (B) edge []           node               {}           (D)
        (C) edge []           node               {}           (E)
        (D) edge [bend left]  node               {$\epsilon$} (F)
        (E) edge [bend right] node [below right] {$\epsilon$} (F);
  \addvmargin{1mm}
\end{nfa} \\
$(E_1E_2)$ & \begin{nfa}
  \node[initial]         (A) [draw]            {$NFA_1$};
  \node[state]           (B) [right of=A]      {};
  \node                  (C) [right of=B,draw] {$NFA_2$};
  \node[state,accepting] (D) [right of=C]      {};
  
  \path (A) edge [] node {}           (B)
        (B) edge [] node {$\epsilon$} (C)
        (C) edge [] node {}           (D);
  \addvmargin{1mm}
\end{nfa} \\
$(E_1)^*$ & \begin{nfa}
  \node[initial,state]   (A)                   {};
  \node                  (B) [right of=A,draw] {$NFA_1$};
  \node[state]           (C) [right of=B]      {};
  \node[state,accepting] (D) [right of=C]      {};
  
  \path (A) edge []           node         {$\epsilon$} (B)
            edge [bend right] node [above] {$\epsilon$} (C)
        (B) edge []           node         {$\epsilon$} (C)
        (C) edge []           node         {}           (D)
            edge [bend right] node [above] {$\epsilon$} (A);
  \addvmargin{1mm}
\end{nfa} \\
\end{tabular}
\caption{De overgang van een reguliere expressie naar een NFA.}
\end{figure}

\subsection{GNFA}

Een NFA kan omgezet worden naar reguliere expressie door de NFA eerst om te zetten naar een GNFA, vervolgens een GNFA met twee toestanden, waaruit de reguliere expressie rechstreeks af te lezen is.

\begin{definitie}{Een gegeneraliseerde NFA}
  \label{def:gnfa}
  Een gegeneraliseerde NFA (GNFA) is een NFA met gewijzigde en extra eigenschappen:
  \begin{itemize}
  \item Er is slechts \'e\'en eindtoestand die verschilt van de begintoestand.
  \item Er komen geen bogen aan in de starttoestand (vanuit andere toestanden) en vanuit de starttoestand vertrekt exact \'e\'en boog naar elke andere toestand.
  \item Er is exact \'e\'en boog van elke toestand naar de eindtoestand.
  \item Tussen elk paar toestanden is er exact \'e\'en boog in beide richtingen.
  \item Er is exact \'e\'en boog van elke toestand naar zichzelf.
  \item Het label van elke boog is een reguliere expressie.
  \end{itemize}
\end{definitie}

\begin{algoritme}{Uitvoering van een GNFA}
  \vspace{-5mm}\begin{enumalgo}
  \item Je start een GNFA met een string $s$.
  \item Je kiest een overgang naar een volgende toestand en verwijder de eerste $n$ symbolen die voldoen aan de reguliere expressie op de gevolgde boog. Bij een boog met enkel $\epsilon$ moet er geen symbool verwijderd worden en het is niet toegestaan om een boog te volgen met als label $\phi$.
  \item Als je aankomt in de eindtoestand en de string is leeg, dan heeft de GNFA de string $s$ aanvaard.
  \end{enumalgo}
\end{algoritme}

\begin{algoritme}{Transformatie NFA naar GNFA}
  \vspace{-5mm}\begin{enumalgo}
  \item Generaliseer de NFA:
    \begin{itemize}
    \item Voer een nieuwe starttoestand $q_s$ in.
    \item Voer een nieuwe (unieke) eindtoestand $q_a$ in.
    \item Teken $\epsilon$-boog van $q_s$ naar de oude begintoestand.
    \item Teken $\epsilon$-boog van elke oude eindtoestand naar $q_e$.
    \item Vul de automaat aan met $\phi$-bogen waar er bogen ontbreken. (Zie definitie \ref{def:gnfa})
    \item Neem parallelle gerichte bogen samen met de unie van hun labels.
    \end{itemize}
  \item Reduceer de GNFA:
    \begin{itemize}
    \item Als $Q \setminus \{q_s, q_e\} = \emptyset$, ga naar stap 3.
    \item Voer een reductiestap uit door een willekeurige knoop $q \in Q \setminus \{q_s, q_e\}$ te verwijderen. (Zie voorbeeld \ref{ex:gnfa})
    \item Herhaal stap 2.
    \end{itemize}
  \item Bepaal de reguliere expressie die af te lezen is als label op de boog tussen $q_s$ en $q_e$.
\end{enumalgo}
\end{algoritme}

% TODO: Bewijs dat elke string die aanvaard wordt voor de reductiestap nadien nog steeds aanvaard wordt
% TODO: Bewijs dat elke string die verworpen wordt voor de reductiestap nadien nog steeds verworpen wordt

\subsection{DFA}

\begin{definitie}{Een deterministische eindige toestandsautomaat}
  \label{def:dfa}
  Een deterministische eindige toestandsautomaat (DFA) is een type automaat dat gelijkt op een NFA, waarvoor de volgende extra eigenschappen gelden:
  \begin{itemize}
  \item Er zijn geen bogen met $\epsilon$.
  \item Elk symbool $a \in \Sigma$ mag hoogstens op \'e\'en uitgaande boog staan per knoop.
  \end{itemize}
\end{definitie}

\begin{definitie}{Een complete DFA}
  \label{def:cdfa}
  Een DFA is compleet wanneer de overgangsfunctie $\delta$ totaal is. D.w.z. dat voor elke $a \in \Sigma$ een overgang mogelijk is vanuit elke toestand. Definitie \ref{def:dfa} beschrijft een parti\"ele DFA. Een parti\"ele (niet-complete) DFA kan omgevormd worden tot een complete DFA door een extra toestand $q_t$ toe te voegen waar alle niet-acceptabele strings in vast komen te zitten. We bepalen een nieuwe overgangsfunctie $\delta'$ voor $Q' = Q \cup \{q_t\}$:
  \begin{equation*}
  \forall q \in Q', a \in \Sigma: \delta'(q, a) = \begin{cases}
    \delta(q, a), & \text{als}\ \delta(q, a) \neq \phi\\
    q_t & \text{anders}
  \end{cases}
  \end{equation*}
\end{definitie}

Definitie \ref{def:cdfa} impliceert ook dat voor elke $a \in \Sigma$ een overgang bestaat van $q_t$ naar $q_t$, waarin $t$ staat voor ``trash".

De complete DFA wordt voornamelijk gebruikt in praktijk. Verder in dit document wordt vaak gebruik gemaakt van een DFA met de assumptie dat $\delta$ een totale functie is. Daarbij wordt impliciet gesteld dat voor een niet-complete DFA eerst de constructie van de equivalente complete DFA wordt uitgevoerd.

\begin{algoritme}{Transformatie NFA naar DFA}
  We construeren een DFA ($Q_d$, $\Sigma$, $\delta_d$, $q_{sd}$, $F_d$) uit een NFA ($Q_n$, $\Sigma$, $\delta_n$, $q_{sn}$, $F_n$) zodanig dat $L_{NFA} = L_{DFA}$ als volgt:
  \begin{itemize}
  \item $Q_d = \powerset(Q_n)$: Elke toestand van de DFA is een verzameling van toestanden van de NFA. Onbereikbare toestanden zullen we later verwijderen, waardoor zal gelden: $Q_d \subseteq \powerset(Q_n)$.
  \item \bm{$\delta_d: (\powerset(Q_n) \times \Sigma) \rightarrow \powerset(Q_n)$}\\$\delta_d(\dfastate, a) = eb(\delta_n(\dfastate, a))$ voor $\dfastate \in Q_d$: Voor een symbool $a$ is er vanuit de toestand van de DFA $\dfastate$ een overgang naar de toestand van de DFA die alle toestanden van de NFA bevat die epsilon-bereikbaar zijn vanuit alle $q \in \dfastate$.
  \item $q_{sd} = eb(q_{sn})$: De starttoestand is de verzameling van toestanden van de NFA die epsilon-bereikbaar zijn vanuit de starttoestand van de NFA.
  \item $F_d = \{S|S \in Q_d, S \cap F_n \neq \emptyset\}$: Een eindtoestand van een DFA bevat altijd een eindtoestand van de NFA.
  \end{itemize}
  Om de constructie uit te voeren hebben we de volgende definities ingevoerd:
  \begin{itemize}
  \item \bm{$eb: Q_n \rightarrow \powerset(Q_n)$}\\ $eb(q) = \{x|x \in \{q\} \cup \delta_n(q, \epsilon)\}$ met $q \in Q_n$: De afbeelding die een toestand $q \in Q_n$ afbeeldt op alle epsilon-bereikbare toestanden. Een toestand $q_{next}$ is epsilon-bereikbaar uit $q$ indien $q_{next} = q$ of er een overgang bestaat zodanig dat $\delta_n(q, \epsilon) = q_{next}$.
  \item \bm{$eb: Q_d \rightarrow \powerset(Q_n)$}\\ $eb(\dfastate) = \{x|x \in \bigcup_{q \in \dfastate}eb(q)\}$ met $\dfastate \in Q_d$: De afbeelding die een toestand $\dfastate \in Q_d$ afbeeldt op alle toestanden die epsilon-bereikbaar zijn vanuit alle toestanden in $\dfastate$.
  \item \bm{$\delta_n: Q_d \times \Sigma \rightarrow \powerset(Q_n)$}\\ $\delta_n(\dfastate, a) = \{x|x \in \bigcup_{q \in \dfastate}\delta_n(q, a)\}$ met $\dfastate \in Q_d$ en $a \in \Sigma$: De afbeelding die een toestand $\dfastate \in Q_d$ afbeeldt op de verzameling van alle toestanden die voor een gegeven symbool bereikbaar zijn vanuit elke toestand in $\dfastate$.
  \end{itemize}
\end{algoritme}

Elke reguliere taal wordt bepaald door een DFA, omdat elke reguliere taal wordt bepaald door een NFA en elke NFA kan worden omgezet tot een DFA.

\begin{definitie}{De overgangsfunctie $\delta^*$ van een DFA voor strings}
  \label{def:deltaster}
  \bm{$\delta^*: (\powerset(Q) \times \sstar) \rightarrow \powerset(Q)$}\\
  $\delta^*$ is een afbeelding die een string afbeeldt op een verzameling toestanden die vanuit een toestand bereikt kunnen worden met die string. We defini\"eren $\delta^*$ inductief:
  \begin{equation*}
    \delta^*(q, s) = \begin{cases}
      q, & \text{als}\ s=\epsilon \\
      \delta^*(\delta(q, a), w) & \text{als}\ s=aw\ \text{voor}\ a \in \Sigma, w \in \sstar
    \end{cases}
  \end{equation*}
\end{definitie}

\begin{bewijs}
  We bewijzen dat $\delta^*(q, wa) = \delta(\delta^*(q, w), a)$ voor $a \in \Sigma, w \in \sstar_\epsilon$.\\[.2cm]
  Bewijs met inductie op basis van definitie \ref{def:deltaster}:
  \begin{itemize}
  \item Stel $w = \epsilon$, dan geldt:\\$\delta^*(q, \epsilon a) = \delta^*(q, a \epsilon) = \delta^*(\delta(q, a), \epsilon) = \delta(q, a) = \delta(\delta^*(q, \epsilon), a)$
  \item Stel $w \neq \epsilon$ en $w = bw'$ met $b \in \Sigma, w' \in \sstar_\epsilon$, dan geldt:\\$\delta^*(q, wa) = \delta^*(q, bw'a) = \delta^*(\delta(q, b), w'a) = \delta(\delta^*(\delta(q, b), w'), a) = \delta(\delta^*(q, w), a)$
  \end{itemize}
\end{bewijs}

\subsection{Minimale DFA}

\begin{definitie}{f-gelijke toestanden}
  Twee toestanden zijn finaal-gelijk indien
  \vspace{-3mm}\begin{equation*}
  \forall w \in \sstar : \delta^*(p, w) \in F \Leftrightarrow \delta^*(q, w) \in F
  \end{equation*}
\end{definitie}

\begin{definitie}{f-verschillende toestanden}
  Twee toestanden zijn finaal-verschillend indien ze niet f-gelijk zijn.
\end{definitie}

Een minimale DFA wordt opgesteld door f-gelijke toestanden samen te nemen. Om het minimaliseren te vergemakkelijken stellen we een totale functie  $\delta'$ op van $\delta$ waarbij in elke toestand voor elk ontbrekend symbool uit het alfabet een overgang wordt toegevoegd zodanig dat $\delta'(q_i, a)=q_i$.

% TODO: Algoritme minimale DFA
% TODO: Bewijs minimale DFA heeft minimaal aantal toestanden
% TODO: Isomorfe DFA's

\subsection{Myhill-Nerode relaties op $\sstar$}

\begin{definitie}{$\partition_1$ is fijner dan $\partition_2$}
  Als een partie $\partition_1$ fijner is dan een $\partition_2$, dan zit elk element van $\partition_1$ vervat in een element van $\partition_2$. $\{\partition_1$, $\partition_2\}$ vormt een tralie waar geldt dat $\partition_1 \leq \partition_2$.
\end{definitie}

\begin{definitie}{$\partition_1$ is groffer dan $\partition_2$}
  Als een partitie $\partition_1$ groffer is dan een $\partition_2$, dan zit elk element van $\partition_2$ vervat in een element van $\partition_1$. $\{\partition_2$, $\partition_1\}$ vormt een tralie waar geldt dat $\partition_2 \leq \partition_1$.
\end{definitie}

\begin{definitie}{Equivalentierelatie $\sim_L$ over $\sstar$}
  Gegeven een taal $L$ over $\Sigma$, is het mogelijk om $\sstar$ op te delen in de partitie $\{L,\overline{L}\}$. De equivalentierelatie $\sim_L$ over $\sstar$ beschouwt twee elementen van $\sstar$ gelijkwaardig indien ze beiden tot dezelfde deelverzameling van die partitie behoren.
  \begin{equation*}
  \forall x, y \in \sstar: x \sim_L y \Leftrightarrow x,y \in L \of x,y \notin L
  \end{equation*}
\end{definitie}

\begin{definitie}{De deelverzameling $reach(q)$ van $\sstar$ voor een DFA}
  De deelverzameling $reach(q)$ van $\sstar$ voor een DFA ($Q$, $\Sigma$, $\delta$, $q_s$, $F$) bevat alle strings die je vanaf de begintoestand $q_s$ in de toestand $q \in Q$ brengen.
  \begin{equation*}
  reach(q) = \{s \in \sstar|\delta^*(q_s,s)=q\}
  \end{equation*}
\end{definitie}

\begin{definitie}{Equivalentierelatie $\sim_{DFA}$ over $\sstar$}
  Gegeven een $DFA$ met $L_{DFA}$ een taal over $\Sigma$, is het mogelijk om $\sstar$ op te delen in de een partitie $\{reach(q)|q \in Q\}$ zodanig dat
  \begin{itemize}
  \item de partitie eindig is.
  \item $s \in \sstar$ wordt aanvaard door de $DFA$ alss $s \in reach(q)$ voor $q \in F$.
  \item als $s \in reach(q)$ dan $\forall a \in \Sigma : sa \in reach(\delta(q, a))$.
  \end{itemize}
  Of in symbolen:
  \begin{equation*}
  \forall x, y \in \sstar: x \sim_{DFA} y \Leftrightarrow \delta^*(q_s, x) = \delta^*(q_s, y)
  \end{equation*}
\end{definitie}

De equivalentierelatie $\sim_{DFA}$ is een $MN(L_{DFA})$-relatie op $\sstar$.

\begin{definitie}{Een Myhill-Nerode relatie voor een taal $L$ over $\sstar$}
  \label{def:mnl}
  Een Myhill-Nerode relatie voor een taal $L$ ($MN(L)$-relatie) is een equivalentierelatie $\sim_X$ die voldoet aan de volgende eigenschappen:
  \begin{itemize}
  \item $\sim_X$ is rechts congruent\\$\forall x, y \in \sstar, a \in \Sigma: x \sim_X y \Rightarrow xa \sim_X ya$
  \item $\sim_X$ verfijnt $\sim_L$\\$x \sim_X y \Rightarrow x \sim_L y$
  \item $\sim_X$ heeft een eindige index\\Het aantal equivalentieklassen van $\sim_X$ is eindig.
  \end{itemize}
\end{definitie}

\begin{bewijs}
  We bewijzen dat een $MN(L)$-relatie enkel bestaat alss de taal $L$ regulier is.\\[.2cm]
  \input{bewijzen/mnlregulier}
\end{bewijs}

% TODO: MN(L) en isomorfe DFA's
% TODO: Supremum van MN(L)-relaties

Het is mogelijk om met een $MN(L)$-relatie te bewijzen dat een taal niet-regulier is. Je gaat te werk door aan te nemen dat als er een minimale DFA bestaat voor de taal, waarvoor men een relatie $\sim_{DFA}$ definieert. Je neemt aan dat die voldoet aan de eerste twee eigenschappen van de definitie (\ref{def:mnl}) en bewijst vervolgens dat het aantal equivalentieklassen van die relatie oneindig is.

% TODO: Stelling van Myhill en Nerode

\subsection{Pompend lemma voor reguliere talen}

Het pompend lemma kan niet gebruikt worden om te bewijzen dat een taal regulier is. Elke reguliere taal moet voldoen aan de eigenschappen van het pompend lemma, maar er zijn ook niet-reguliere talen die daaraan voldoen. Daardoor kan je met zekerheid zeggen dat een taal niet-regulier is als je ze niet kan pompen, maar je kan niet met zekerheid zeggen dat een taal regulier is. In FO-logica $Regulier(L) \rightarrow KanPompen(L)$ met waarheidstabel:
\begin{center}
\begin{tabular}{r|c|c}
                     & $KanPompen(L)$ & $\neg KanPompen(L)$ \\ \hline
  $Regulier(L)$      & True           & False               \\ \hline
  $\neg Regulier(L)$ & True           & True
\end{tabular}
\end{center}

\begin{definitie}{Het pompend lemma voor reguliere talen}
  Voor een reguliere taal $L$ bestaat een pomplengte $d$ zodanig dat als $s \in L$ en $|s| \geq d$, er minstens \'e\'en verdeling bestaat van $s$ in stukken $x$, $y$ en $z$ met $s = xyz$ en
  \begin{enumerate}
  \item $\forall i \geq 0: xy^iz \in L$
  \item $|y| > 0$
  \item $|xy| \leq d$
  \end{enumerate}
\end{definitie}

\begin{bewijs}
  We bewijzen de eigenschappen van het pompend lemma. \\[.2cm]
  Voor een DFA die een taal $L$ bepaalt nemen we een pomplengte $d = \#Q + 1$ en een willekeurige string $s = a_1a_2a_3...a_n$ met $n \geq d$. De accepterende sequentie van toestanden ($q_s = q_1$, $q_2$, ..., $q_f$) voor s heeft een lengte strikt groter dan het aantal toestanden in $Q$, dus er zijn bij de eerste $d$ toestanden zeker twee toestanden gelijk omdat er maar $d-1$ toestanden zijn. Stel dat $q_i$ en $q_j$ gelijk zijn met $i < j \leq d$, dan nemen we
  \begin{equation*}
  \begin{cases}
  x = a_1a_2...a_i\\
  y = a_{i+1}a_{i+2}...a_j\\
  z = a_{j+1}a_{j+2}...a_n
  \end{cases}
  \end{equation*}
  \begin{itemize}
  \item Eigenschap 1 geldt omdat $y$ een lus volgt en die $k$ keer herhaald kan worden voor $xy^kz \in L$.
  \item Eigenschap 2 geldt omdat $i$ strikt kleiner is dan $j$, dus bevat $y$ minstens \'e\'en element.
  \item Eigenschap 3 geldt omdat $i < j \leq d$, dus we hebben $xy$ kleiner dan (of gelijk aan) $d$ gekozen.
  \end{itemize}
\end{bewijs}

% TODO: Voorbeeld gebruiken van pompend lemme of aan te tonen dat een taal niet-regulier is
% TODO: Algebra van DFAs

\subsection{Andere automaten}

\begin{definitie}{B\"uchi automaat}
  Een B\"uchi automaat (BA) is een automaat die lijkt op een NFA, maar deze doorlopen oneindige strings. Een BA accepteert een string indien de rij toestanden die gepasseerd wordt oneindig dikwijls een accepterende toestand bevat.
\end{definitie}

\newpage\section{Contextvrije talen}

\begin{definitie}{Contextvrije grammatica}
  Een contextvrije grammatica (CFG) is een 4-tal ($V$, $\Sigma$, $R$, $S$) waarbij
  \begin{itemize}
  \item $V$ een eindige verzameling niet-eindsymbolen is (variabelen of non-terminals)
  \item $\Sigma$ een eindig alfabet van eindsymbolen (terminals), disjunct met $V$
  \item $R$ een eindige verzameling regels (producties) is die bestaan uit een koppel van een variabele en een string $s \in \sstar_\epsilon$, gescheiden door $\rightarrow$
  \item $S \in V$ is de starttoestand
  \end{itemize}
\end{definitie}

\begin{definitie}{Afleiding/constructie m.b.v. een CFG}
  Gegeven een CFG ($V$, $\Sigma$, $R$, $S$) en een string $f$ over $V \cup \Sigma_\epsilon$, dan kan men een string $b$ over $V \cup \Sigma_\epsilon$ afleiden/construeren uit $f$ ($b \Rightarrow^* f$) met de gegeven CFG, indien er er een rij strings $s_0,s_1,s_2,...,s_n$ bestaat zodanig dat
  \begin{itemize}
  \item $s_0 = b$
  \item $s_n = f$
  \item $s_{i+1}$ is gelijk aan $s_i$ (met $i < n$) waarin een variabele $X$ wordt vervangen door de rechterzijde van een productie waarin $X$ aan de linkerzijde voorkomt.
  \end{itemize}
\end{definitie}

\begin{definitie}{Taal $L_{CFG}$ bepaald door een CFG}
  Een taal $L_{CFG}$ bepaald door een CFG ($V$, $\Sigma$, $R$, $S$) is een verzameling van strings over $\Sigma$ die kan afgeleid worden uit het startsymbool $S$.
  \begin{equation*}
  L_{CFG} = \{s \in \sstar|S \Rightarrow^* s\}
  \end{equation*}
\end{definitie}

\begin{definitie}{Contextvrije taal}
  Een taal $L$ is een contextvrije taal (CFL) indien er een CFG bestaat zodanig dat $L = L_{CFG}$.
\end{definitie}

\begin{definitie}{Ambigue strings}
  Een string is ambigu indien er voor die meerdere meest-linkse (of meest-rechtse) afleidingen bestaan.
\end{definitie}

\begin{definitie}{Ambigue CFG's}
  Een CFG is ambigu indien er strings $s \in L_{CFG}$ die ambigue zijn t.o.v. de CFG.
\end{definitie}
Sommige CFL's hebben niet-ambigue CFG, maar dat geldt niet voor elke CFL. Een CFL die geen niet-ambigue CFG heeft is inherent ambigu.

\begin{definitie}{Equivalente CFG's}
  Twee CFG's zijn equivalent indien ze dezelfde taal bepalen.
  \begin{equation*}
  L_{CFG_1} = L_{CFG_2}
  \end{equation*}
\end{definitie}

\begin{definitie}{Chomsky Normaal Vorm}
  \label{def:cnf}
  Elke CFG heeft een Chomsky Normaal Vorm (CNF) die dezelfde taal genereert en waarbij de producties een beperkt aantal vormen kan aannemen:
  \begin{itemize}
  \item $A \rightarrow BC$ met $\begin{cases}A \in V \\ B,C \in V \setminus \{S\}\end{cases}$
  \item $A \rightarrow \alpha$ met $\begin{cases}A \in V \\ \alpha \in \Sigma\end{cases}$
  \item $S \rightarrow \epsilon$
  \end{itemize}
\end{definitie}

Met de CNF
\begin{itemize}
\item kan je onmiddellijk zien of $L_{CFG}$ de lege string bevat.
\item is elke parse tree (bijna) een volledige binaire boom.
\item heeft de afleiding van een string van lengte $n > 0$ altijd een lengte $2n-1$.
\end{itemize}

% TODO: Bewijs CNF

\begin{definitie}{Greibach Normaal Vorm}
  Elke CFG heeft een Greibach Normaal Vorm (GNF) die dezelfde taal genereert en waarbij de producties een beperkt aantal vormen kan aannemen:
  \begin{itemize}
  \item $A \rightarrow \alpha X$ met $\begin{cases}A \in V \\ \alpha \in \Sigma \\ X = X_1X_2X_3...X_n \text{ met } X_i \in V, n \in \nat\end{cases}$
  \item $S \rightarrow \epsilon$
  \end{itemize}
\end{definitie}

\subsection{PDA}

\begin{definitie}{Push-down automaat}
  Een push-down automaat (PDA) is een 6-tal ($Q$, $\Sigma$, $\Gamma$, $\delta$, $q_s$, $F$) waarbij
  \begin{itemize}
  \item $Q$ is een eindige verzameling toestanden
  \item $\Sigma$ is een eindige inputalfabet
  \item $\Gamma$ is een eindige stapelalfabet
  \item \bm{$\delta: Q \times \Sigma_\epsilon \times \Gamma_\epsilon \rightarrow \powerset(Q \times \Gamma_\epsilon)$}\\$\delta$ is een overgangsfunctie
  \item $q_s$ is de starttoestand
  \item $F \subseteq Q$ is een verzameling eindtoestanden
  \end{itemize}
\end{definitie}

\begin{figure}[!ht]
  \label{fig:pdasstep}
  \centering
  \begin{pda}
  \node[state] (A) []               {};
  \node[state] (B) [right=3cm of A] {};
  
  \path (A) edge [] node {$\alpha,\beta\rightarrow\gamma$} (B);
  \addvmargin{1mm}
  \end{pda}
  \caption{Een overgang van een PDA.}
\end{figure}

\begin{nobreakparagraph}
Een PDA maakt overgangen zoals in figuur \ref{fig:pdasstep},
\begin{itemize}
\item indien $\alpha$ het eerste symbool is van de string
\item en $\beta$ bovenaan de stapel staat,
\item je kan die boog volgen en
\begin{itemize}
\item $\alpha$ van de string verwijderen
\item $\beta$ van de stapel verwijderen
\item $\gamma$ op de stapel plaatsen
\end{itemize}
\end{itemize}
\end{nobreakparagraph}
Indien de PDA niet-deterministisch is, kunnen er meerdere bogen met dezelfde $\alpha,\beta$ combinaties vertrekken uit een toestand.

% TODO: Aanvaarding van een string door een PDA

Alternatieve definities van een PDA:
\begin{itemize}
\item Er mag meer dan \'e\'en symbool op de stapel geplaatst worden tijdens een overgang.
\item Een string wordt geaccepteerd indien de string op is en de stapel leeg is ($F$ heeft geen belang).
\item Een string wordt geaccepteerd indien de string op is, de stapel leeg is en we in een eindtoestand zitten.
\item In een overgang wordt een symbool op de stapel geplaatst maar er wordt geen symbool van de stapel verwijderd of omgekeerd.
\item Er is slechts \'e\'en eindtoestand.
\end{itemize}
Voor een CFL is het mogelijk om met eender welke van deze definities equivalente automaten te maken.

% TODO: Bewijs equivalentie CFG en PDA

\begin{algoritme}{Constructie van een PDA uit een CFG}
  \label{alg:cfgpda}
  We stellen een PDA ($Q$, $\Sigma_{PDA}$, $\Gamma$, $\delta$, $q_s$, $F$) voor een CFG ($V$, $\Sigma_{CFG}$, $R$, $S$) met
  \begin{itemize}
  \item $Q = {q_s, q_h, q_a}$ met $q_h$ een hulptoestand
  \item $\Sigma_{PDA} = \Sigma_{CFG}$
  \item $\Gamma = \{\$\} \cup V \cup \Sigma_{CFG}$
  \item $\delta$ waarvoor geldt:
  \begin{itemize}
  \item Er is 1 boog van $q_s$ naar $q_h$ met label ``$\epsilon,\epsilon\rightarrow\$$".
  \item Er is 1 boog van $q_h$ naar $q_a$ met label ``$\epsilon,\$\rightarrow\epsilon$".
  \item Voor elk symbool $a \in \Sigma_{CFG}$ is er een lus bij $q_h$ met label ``$a,a\rightarrow\epsilon$".
  \item Voor elke productie $(X \rightarrow \gamma) \in R$ is er een lus bij $q_h$ met label ``$\epsilon,X\rightarrow\gamma$". (Vervang de linkerkant van een productie bovenaan de stapel met de rechterkant van de productie.)
  \end{itemize}
  \item $q_s$ de starttoestand
  \item $F = \{q_a\}$ met $q_a$ de eindtoestand
  \end{itemize}
\end{algoritme}

Om een meest-linkse afleiding te bekomen moeten we in algoritme \ref{alg:cfgpda} de symbolen van een string $\gamma \in \sstar_\epsilon$ in omgekeerde volgorde op de stapel plaatsen.

% TODO: Een PDA accepteert een L_CFG
% TODO: Constructie CFG uit PDA

\subsection{Pompend lemma voor contextvrije talen}

\begin{definitie}{Het pompend lemma voor contextvrije talen}
  Voor een contextvrije taal $L$ bestaat een pomplengte $d$ zodanig dat als $s \in L$ en $|s| \geq d$, er minstens \'e\'en verdeling van $s$ bestaat in stukken $u$, $v$, $x$, $y$, $z$ met $s = uvxyz$ en
  \begin{enumerate}
  \item $\forall i \geq 0: uv^ixy^iz \in L$
  \item $|vy| > 0$
  \item $|vxy| \leq d$
  \end{enumerate}
\end{definitie}

Net zoals bij het pompend lemma voor reguliere talen, is het niet mogelijk om met deze variant te bewijzen dat een taal regulier is, omdat het een eigenschap is van een CFL, maar er zijn ook niet-contextvrije talen die die eigenschap zouden kunnen hebben. Het is enkel mogelijk om aan te tonen dat als deze eigenschap niet geldig is, dat een taal niet contextvrij is.

\begin{bewijs}
  We bewijzen het pompend lemma voor contextvrije talen.\\[.2cm]
  Voor een taal $L$ nemen we een CFG in CNF, waardoor er voor elke $s \in L$ een parse tree bestaat. Omdat de CFG in CNF staat, weten we dat elk blad onderaan de boom een terminal is, die (voor een niet-lege string $s$) volgt uit een productie met vorm ``$A \rightarrow \alpha$". Elke andere knoop in de boom moet dan volgen uit een productie met vorm ``$A \rightarrow BC$". Daarom kunnen we weggen dat indien we alle bladeren van de boom wegsnoeien, we een perfecte binaire boom bekomen, die een hoogte heeft van minstens $log_2|s|$.
  
  Het langste enkelvoudig pad vanaf de wortel van de parse tree moet minstens een lengte hebben van $log_2|s| + 1$. We nemen een string $s \in L$ waarvoor geldt dat $log_2|s| + 1 > n$ met $n = \#V + 1$ Dus er moet minstens \'e\'en variabele $X$ herhaald worden. Vanwege de definitie van de CNF (definitie \ref{def:cnf}) geldt dat $X \neq S$. We nemen op dat pad een $X_1$ en de dichtste herhaling $X_2$ (zie figuur \ref{fig:pumptree}). We kunnen nu de afleiding construeren als
  \begin{equation*}
  S \Rightarrow^* uX_2z \Rightarrow^* uvX_1yz \Rightarrow^* uvxyz \text{ met }u,v,x,y,z \in \sstar
  \end{equation*}
  
  \begin{itemize}
  \item Eigenschap 1 geldt omdat indien de bovenstaande afleiding geldt, de volgende afleidingen ook moeten gelden:
  \begin{equation*}
  S \Rightarrow^* uX_2z \Rightarrow^* uxz
  \end{equation*}
  \begin{equation*}
  S \Rightarrow^* uXz \Rightarrow^* uvXyz \Rightarrow^* uvvxyyz
  \end{equation*}
  \item Eigenschap 2 geldt omdat $v$ en $y$ niet tegelijkertijd leeg kunnen zijn, want dan zou men $X$ uit zichzelf kunnen afleiden en dat kan niet vanwege de vorm van de CFG.
  \end{itemize}
  
  Deze eigenschappen zijn geldig voor strings langer dan de pomplengte, dus $d = 2^{n-1}$.
  
  \begin{itemize}
  \item Eigenschap 3 geldt omdat $vxy$ afgeleid wordt uit een $X$ met een parse tree die lager is dan $n$, dus hoogstens $d$ bladeren heeft, wat juist correspondeert met $vxy$.
  \end{itemize}
\end{bewijs}

\begin{figure}[ht]
  \label{fig:pumptree}
  \centering
  \begin{tikzpicture}[-,
    >=stealth',
    shorten >=1pt,
    auto,
    node distance=1cm]
  \tikzstyle{every state}=[fill=none,draw=none,text=black]
  
  \node (S)                {$S$};
  \node (X2) [below of=S]  {$X_2$};
  \node (X1) [below of=X2] {$X_1$};
  \node (x)  [below of=X1] {$x$};
  \node (l3) [left of=x]   {};
  \node (v)  [left of=l3]  {$v$};
  \node (l2) [left of=v]   {};
  \node (u)  [left of=l2]  {$u$};
  \node (l1) [left of=u]   {};
  \node (l4) [right of=x]  {};
  \node (y)  [right of=l4] {$y$};
  \node (l5) [right of=y]  {};
  \node (z)  [right of=l5] {$z$};
  \node (l6) [right of=z]  {};
  
  \path (S)  edge []                   node {} (X2)
             edge [bend right]         node {} (l1)
             edge [bend left]          node {} (l6)
        (X2) edge [dotted]             node {} (X1)
             edge [dotted, bend right] node {} (l2)
             edge [dotted, bend left]  node {} (l5)
        (X1) edge [dotted]             node {} (X1)
             edge [dotted, bend right] node {} (l3)
             edge [dotted, bend left]  node {} (l4);
  \end{tikzpicture}
  \caption{De parse tree met de repeterende variabele $X$.}
\end{figure}

% TODO: Toepassing pompend lemma voor CFL
% TODO: Algebra van CFL's
% TODO: Ambiguiteit en DPDA
% TODO: Contextgevoelige grammatica

\section{Chomsky hi\"erarchie}

De Chomsky hi\"erarchie is een hi\"erarchische rangschikking van talen. Elke klasse van talen in de hi\"erarchie zit vervat in een sterkere klasse van talen, met de grootste klasse (die van de Turing-herkenbare talen) zijnde een deelverzameling van $L_\Sigma$:
\begin{itemize}
\item Type-0: De klasse van de herkenbare talen heeft een onbeperkte grammatica, dat wil zeggen er geen restricties zijn op de grammaticale regels. Elke taal die door een Turingmachine herkent wordt zit in deze klasse.
\item Type-1: De klasse van de contextgevoelige talen heeft een contextgevoelige grammatica, daarbij mogen de productieregels in tegenstelling tot een CFG zowel aan de linker- als rechterzijde een combinatie van variabelen en terminals bevatten. Elke taal die door een lineair begrensde automaat (Turingmachine) bepaalt wordt zit in deze klasse. Een LBA kan een beslissingsprobleem oplossen in $O(n)$-ruimte.
\item Type-2: De klasse van de contextvrije talen heeft een contextvrije grammatica (CFG). Elke taal die door een push-down automaat bepaalt wordt zit in deze klasse. Het parsen van een string uit een taal $L_{CFG}$ kan in $O(n^2)$-tijd.
\item Type-3: De klasse van de reguliere talen heeft een reguliere grammatica. Elke taal die door een eindige toestandsautomaat bepaalt wordt zit in deze klasse. Een string uit een taal $L_{RE}$ kan herkend worden in $O(n)$-tijd.
\end{itemize}

\begin{figure}[ht]
\centering
  \begin{tikzpicture}
  \path
    (0,0) rectangle (8,6) [draw]
    (1.5,5.5) node {$L_\Sigma = \powerset(\sstar)$}
    (4,2.75) coordinate (A) node[above=1.5cm] {Turing-herkenbare talen} ellipse (3.5 and 2.5) [draw]
    (4,2.25) coordinate (B) node[above=1cm] {Contextsensitieve talen} ellipse (3 and 2) [draw]
    (4,1.75) coordinate (C) node[above=0.5cm] {Contextvrije talen} ellipse (2.5 and 1.5) [draw]
    (4,1.25) coordinate (D) node {Reguliere talen} ellipse (2 and 1) [draw];
  \end{tikzpicture}
  \caption{Een voorstelling van de Chomsky-hi\"erarchy.}
\end{figure}

\section{Turingmachines}

\begin{definitie}{Turingmachine}
  Een Turingmachine (TM) is een 7-tal ($Q$, $\Sigma$, $\Gamma$, $\delta$, $q_s$, $q_a$, $q_r$) waarbij
  \begin{itemize}
  \item $Q$ een eindige verzameling toestanden
  \item $\Sigma$ een eindig invoer alfabet dat $\#$ niet bevat
  \item $\Gamma$ een eindig tape alfabet met $\# \in \Gamma$ en $\Sigma \subset \Gamma$
  \item $q_s$ de starttoestand
  \item $q_a$ de accepterende eindtoestand
  \item $q_r$ de verwerpende eindtoestand verschillend van $Q_a$
  \item \bm{$\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, S\}$}\\$\delta$ de (totale) transitiefunctie
  \end{itemize}
\end{definitie}

$\#$ wordt gebruikt om aan te geven dat een positie op de band van de TM nog niet beschreven is. We noemen dit het blanco symbool.

% TODO: Werking TM

\begin{definitie}{Opdeling van $\sstar$ door een TM}
  Een TM kan $\sstar$ in drie disjuncte stukken opdelen:
  \begin{itemize}
  \item $L_{TM}$: De taal met alle strings die door de TM worden geaccepteerd.
  \item $\infty_{TM}$: De taal met alle strings waarvoor de TM niet stopt.
  \item De resterende strings die door de TM worden verworpen.
  \end{itemize}
\end{definitie}

\begin{definitie}{(Turing-)herkenbaarheid}
  \vspace{-5mm}\begin{itemize}
  \item Een Turingmachine $TM$ herkent een taal $L_{TM}$.
  \item Een taal $L$ is herkenbaar indien er een Turingmachine $TM$ bestaat zodanig dat $L = L_{TM}$.
  \end{itemize}
\end{definitie}

\begin{definitie}{Co-herkenbaarheid}
  Een taal $L$ is co-herkenbaar indien $\overline{L}$ herkenbaar is.
\end{definitie}

\begin{definitie}{(Turing-)beslisbaarheid}
  \vspace{-5mm}\begin{itemize}
  \item Een Turingmachine $TM$ beslist een taal $L_{TM}$ indien $TM$ $L$ herkent en $\infty_{TM} = \emptyset$.
  \item Een taal $L$ is beslisbaar indien er een Turingmachine $TM$ bestaat zodanig die $L$ beslist.
  \item Een taal $L$ is beslisbaar indien ze herkenbaar en co-herkenbaar is.
  \end{itemize}
\end{definitie}

\begin{definitie}{Co-beslisbaarheid}
  Een taal $L$ die beslisbaar is is ook co-beslisbaar.
\end{definitie}

\begin{bewijs}
  We bewijzen co-beslisbaarheid.\\[.2cm]
  Als een beslisser $B$ de taal $L$ beslist, dan stopt die beslisser voor elke invoer bij de accepterende eindtoestand $q_a$ of de verwerpende eindtoestand $q_r$. We kunnen een beslisser $B'$ construeren voor $\overline{L}$ door bij $B$ de toestanden $q_a$ en $q_r$ om te wisselen. Omdat $B$ ook stopt voor alle strings die niet tot de taal behoren zal $B'$ die strings accepteren en alle strings die $B$ accepteert verwerpen. Bijgevolg is $\overline{L}$ beslisbaar.
\end{bewijs}

\begin{bewijs}
  We bewijzen dat een taal beslisbaar is als ze herkenbaar en co-herkenbaar is.\\[.2cm]
  Stel een machine $M_1$ herkent $L$ en een machine $M_2$ herkent $\overline{L}$. We construeren nu een machine $M$ die voor een string beide machines $M_1$ en $M_2$ laat lopen. Indien $M_1$ de string accepteert, dan accepteert $M$ de string. Indien $M_2$ de string accepteert, dan verwerpt $M$ de string. Omdat $M_1$ alle strings accepteert uit $L$ en $M_2$ alle strings uit $\overline{L}$, zal $M$ voor elke invoer stoppen in een eindtoestand. Bijgevolg is $M$ een beslisser voor $L$, dus is $L$ beslisbaar.
\end{bewijs}

\include{voorbeelden}
\include{examenvragen}

\end{document}
