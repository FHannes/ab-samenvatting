\documentclass[a4paper]{article}

\usepackage[dutch]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{parskip}
\usepackage{array}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{pifont}
\usepackage{tabularx}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,calc,fit,positioning}
\usepackage{chngcntr}
\counterwithin{figure}{section}

\begingroup
    \makeatletter
    \@for\theoremstyle:=definition,remark,plain\do{%
        \expandafter\g@addto@macro\csname th@\theoremstyle\endcsname{%
            \addtolength\thm@preskip\parskip
            }%
        }
\endgroup

\newcommand\addvmargin[1]{
  \node[fit=(current bounding box),inner ysep=#1,inner xsep=0]{};
}

\definecolor{silver}{rgb}{0.95,0.95,0.95}

\newtheorem{tdefinitie}{Definitie}[section]
\newenvironment{definitie}[1]%
  {\begin{mdframed}[backgroundcolor=silver,
    topline=false,
    rightline=false,
    leftline=false,
    bottomline=false]\begin{tdefinitie}#1\\\normalfont}%
  {\end{tdefinitie}\end{mdframed}}

\newtheorem{talgo}{Algoritme}[section]
\newenvironment{algoritme}[1]%
  {\begin{mdframed}[backgroundcolor=silver,
    topline=false,
    rightline=false,
    leftline=false,
    bottomline=false]\begin{talgo}#1\\\normalfont}%
  {\end{talgo}\end{mdframed}}
  
\renewcommand{\qedsymbol}{$\blacksquare$}
\newenvironment{bewijs}[1]%
  {\begin{mdframed}[topline=true,
    rightline=true,
    leftline=true,
    bottomline=true]\begin{proof}[Bewijs]#1\\[.2cm]\normalfont}%
  {\end{proof}\end{mdframed}}
 
\newenvironment{nfa}%
  {\begin{tikzpicture}[->,
    >=stealth',
    shorten >=1pt,
    auto,
    node distance=2cm,
    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]
  \tikzstyle{accepting}=[accepting by double]
  \tikzstyle{every initial by arrow}=[initial text=]}%
  {\end{tikzpicture}}
 
\newenvironment{pda}%
  {\begin{tikzpicture}[->,
    >=stealth',
    shorten >=1pt,
    auto,
    node distance=2cm,
    semithick]
  \tikzstyle{every state}=[fill=none,draw=black,text=black]
  \tikzstyle{accepting}=[accepting by double]
  \tikzstyle{every initial by arrow}=[initial text=]}%
  {\end{tikzpicture}}
  
\newenvironment{enumalgo}%
  {\begin{enumerate}[leftmargin=1.5cm,label=Stap \arabic*:]}%
  {\end{enumerate}}
  
\newenvironment{nobreakparagraph}%
  {\par\nobreak\vfil\penalty0\vfilneg\vtop\bgroup}%
  {\par\xdef\tpd{\the\prevdepth}\egroup\prevdepth=\tpd}%
  
\newcommand{\powerset}{\ensuremath{\mathcal{P}}}
\newcommand{\partition}{\ensuremath{\mathfrak{P}}}
\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\whole}{\ensuremath{\mathbb{Z}}}
\newcommand{\dfastate}{\ensuremath{\mathcal{Q}}}
\newcommand{\en}{\ensuremath{\text{ en }}}
\newcommand{\of}{\ensuremath{\text{ of }}}
\newcommand{\sstar}{\ensuremath{\Sigma^*}}
\newcommand{\atm}{\ensuremath{{A_{TM}}}}
\newcommand{\htm}{\ensuremath{{H_{TM}}}}
\newcommand{\etm}{\ensuremath{{E_{TM}}}}
\newcommand{\eqtm}{\ensuremath{{EQ_{TM}}}}
\newcommand{\oatm}{\ensuremath{{O^\atm}}}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\begin{document}

\begin{titlepage}
    \newpage
    \thispagestyle{empty}
    \frenchspacing
    \hspace{-0.2cm}
    \includegraphics[height=3.4cm]{assets/sedes}
    \hspace{0.2cm}
    \rule{0.5pt}{3.4cm}
    \hspace{0.2cm}
    \begin{minipage}[b]{8cm}
        \large{Katholieke\newline Universiteit\newline Leuven}\smallskip\newline
        \large{}\smallskip\newline
        \textbf{Department \newline Computerwetenschappen}\smallskip
    \end{minipage}
    \hspace{\stretch{1}}
    \vspace*{3.2cm}\vfill
    \begin{center}
        \begin{minipage}[t]{\textwidth}
            \begin{center}
                \large{\rm{\textbf{\uppercase{Samenvatting}}}}\\
                \large{\rm{Automaten en Berekenbaarheid [G0P84a]}}
            \end{center}
        \end{minipage}
    \end{center}
    \vfill
    \hfill\makebox[3cm][l]{%
        \vbox to 7cm{\vfill\noindent
            {\rm \textbf{Fr\'ed\'eric Hannes}}\\[2mm]
            {\rm Academisch jaar 2015--2016}
        }
    }
\end{titlepage}

\tableofcontents

\newpage

\section{Voorkennis}

\subsection{Belangrijke afkortingen}

\begin{tabular}{l|l}
	alss & Als en alleen als ($\Leftrightarrow$) \\
\end{tabular}

\subsection{Wiskundige symbolen}

\begin{tabular}{l|l}
	$\vee$ & Supremum \\
	$\wedge$ & Infimum \\
	$\triangleq$ & Is per definitie gelijk aan \\
\end{tabular}

\subsection{Griekse letters}

\begin{tabular}{l|l|l}
	Alpha & $\alpha$ & \\
	Beta & $\beta$ & \\
	Delta & $\delta$ & $\Delta$ \\
	Epsilon & $\varepsilon, \epsilon$ & \\
	Gamma & $\gamma$ & $\Gamma$ \\
	Mu & $\mu$ & \\
	Omega & $\omega$ & $\Omega$ \\
	Phi & $\varphi, \phi$ & $\Phi$ \\
	Rho & $\rho$ & \\
	Sigma & $\sigma$ & $\Sigma$ \\
	Tau & $\tau$ & \\
	Theta & $\theta$ & $\Theta$ \\
	Xi & $\xi$ & $\Xi$ \\
\end{tabular}

\subsection{Verzamelingenleer}

\begin{definitie}{Een algebra van een verzameling S}
Een algebra is een verzameling met daarop een aantal inwendige operaties.
\end{definitie}

\begin{definitie}{De unie van twee verzamelingen}
  De unie van twee verzamelingen $S_1$ en $S_2$ is de verzameling die alle elementen bevat die in $S_1$ en/of $S_2$ zitten. \\
  \\ $S_1 \cup S_2 = \{x|x \in S_1 \of x \in S_2\}$
\end{definitie}

\begin{definitie}{De doorsnede van twee verzamelingen}
  De doorsnede van twee verzamelingen $S_1$ en $S_2$ is de verzameling die alle elementen bevat die in zowel $S_1$ als $S_2$ zitten. \\
  \\ $S_1 \cup S_2 = \{x|x \in S_1 \en x \in S_2\}$
\end{definitie}

\begin{definitie}{Het complement van een verzameling}
  Het complement van een verzameling $S$ van alle elementen uit het domein die niet in $S$ zitten. \\
  \\ $\overline{S} = \{x|x \notin S\}$
\end{definitie}

\begin{definitie}{Een machtsverzameling $\powerset(S)$ van een verzameling $S$}
  Een machtsverzameling $\powerset(S)$ is een verzameling van alle deelverzamelingen die gevormd kunnen worden met de elementen in S, inclusief de lege verzameling en de verzameling A.\\ \\ $\powerset(S) = \{A|A \subseteq S\}$
\end{definitie}

\begin{definitie}{Een equivalentierelatie $\sim$ op een verzameling $S$}
  Een equivalentierelatie ($\sim$) is een relatie die de elementen van een verzameling groepeert die allemaal voldoen aan een zekere set criteria. Elke equivalentierelatie is
  \begin{itemize}
  \item reflexief: $\forall x \in S: x \sim x$
  \item symmetrisch: $\forall x, y \in S: x \sim y \Leftrightarrow y \sim x$
  \item transitief: $\forall x, y, z \in S: x \sim y \en y \sim z \Rightarrow x \sim z$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een equivalentieklasse onder $\sim$ op een verzameling $S$}
  Een equivalentieklasse ($x_\sim \subseteq S$) is de verzameling van alle elementen in de verzameling $S$ die onder de gegeven equivalentierelatie gelijkwaardig zijn aan $x$. \\
  \\ $x_\sim = \{y \in S|x \sim y\}$
\end{definitie}

\begin{definitie}{Een partitie $\partition$ van een verzameling $S$}
  Een partitie van een verzameling is een opdeling van de elementen van die verzameling in niet-lege onderling disjuncte delen. Als $\partition$ een partitie is van een verzameling $S$, dan geldt:
  \begin{itemize}
  \item $\emptyset \notin \partition$
  \item $\forall X, Y \in \partition: X \neq Y \Rightarrow X \cap Y = \emptyset$
  \item $\bigcup_{X \in \partition} = S$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een tralie ($L$, $\leq$, $\vee$, $\wedge$)}
  Een tralie is een partieel-geordende verzameling, geordend volgens $\leq$, met een supremum ($\vee$) en een infimum ($\wedge$) voor elk paar elementen. Voor een tralie geldt:
  \begin{itemize}
  \item $\forall x, y \in L: x \leq y \Rightarrow x = x \wedge y$
  \item $\forall x, y \in L: x \leq y \Rightarrow y = x \vee y$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een volledige tralie ($L$, $\leq$, $\vee$, $\wedge$)}
  Een tralie is een volledige tralie indien elke deelverzameling van $L$ een bovengrens en ondergrens heeft die een elementen zijn van $L$. \\
  \\ $\forall X \subseteq L: \bigwedge_X \in L \en \bigvee_X \in L$
\end{definitie}

\newpage\section{Inleiding talen}

\begin{definitie}{Een alfabet $\Sigma$}
  Een verzameling van symbolen.
\end{definitie}

\begin{definitie}{Een string $s$ over een alfabet $\Sigma$}
  Een opeenvolging nul, \'e\'en of meerdere elementen uit $\Sigma$. \\
  \\ $s = a_1a_2a_3...a_n$ met $a_i \in \Sigma, n \in \nat$
  \\ $s \in L$
\end{definitie}

\begin{definitie}{De lege string $\epsilon$ over een alfabet $\Sigma$}
  De lege string is een string die bestaat uit nul elementen.
\end{definitie}

\begin{definitie}{Het alfabet $\Sigma_\epsilon$}
  $\Sigma_\epsilon = \Sigma \cup \{\epsilon\}$
\end{definitie}

\begin{definitie}{Een taal $L$ over een alfabet $\Sigma$}
  Een verzameling van strings over $\Sigma$.\\
  \\ $L \subseteq \sstar$
  \\ $L \in L_\Sigma$
\end{definitie}

\begin{definitie}{Concatenatie van twee talen}
  $L_1L_2$ is de concatenatie van twee talen $L_1$ en $L_2$ over hetzelfde alfabet $\Sigma$. \\
  \\ $L_1L_2 = \{xy|x \in L_1, y \in L_2\}$
  \\ $L^n = \{x_1x_2x_3...x_n|x_i \in L, n \in \nat\}$
  \\ $L^0 = \{\epsilon\}$
\end{definitie}

\begin{definitie}{De Kleene ster $L^*$ van een taal $L$}
  $L^* = \bigcup^\infty_{n=0}L^n$
  \\ $L^+ = LL^*$
\end{definitie}

\begin{definitie}{De verzameling $\sstar$ van alle strings over $\Sigma$}
  $\sstar$ is een verzameling met alle strings die gevormd kunnen worden uit het alfabet $\Sigma$. Elke taal over $\Sigma$ is een deelverzameling van $\sstar$. \\
  \\ $\sstar = \{a_1a_2a_3...a_n|a_i \in \Sigma, n \in \nat\}$
\end{definitie}

\begin{definitie}{De verzameling $L_\Sigma$ van alle talen over $\Sigma$}
  $L_\Sigma = \powerset(\sstar)$ is een verzameling met alle talen die gevormd kunnen worden uit het alfabet $\Sigma$. Elke taal over $\Sigma$ is een element van $\powerset(\sstar)$.
\end{definitie}

De verzameling $L_\Sigma$ vormt een algebra met verschillende inwendige operaties, waaronder:
\begin{itemize}
\item Unie: $L_1 \cup L_2 \in L_\Sigma$ met $L_1 \in L_\Sigma, L_2 \in L_\Sigma$
\item Doorsnede: $L_1 \cap L_2 \in L_\Sigma$ met $L_1 \in L_\Sigma, L_2 \in L_\Sigma$
\item Complement: $\overline{L} \in L_\Sigma$ met $L \in L_\Sigma$
\item Concatenatie: $L_1L_2 \in L_\Sigma$ met $L_1 \in L_\Sigma, L_2 \in L_\Sigma$
\item Willekeurig lange concatenatie: $L_1^* \in L_\Sigma$ met $L_1 \in L_\Sigma$
\end{itemize}

\newpage\section{Reguliere talen}

\begin{definitie}{Een reguliere expressie $E$ over een alfabet $\Sigma$}
  $E$ is een reguliere expressie over $\Sigma$ indien $E$ van de vorm is:
  \begin{itemize}
  \item $\epsilon$ (lege string)
  \item $\phi$
  \item $a$ met $a \in \Sigma$
  \item $(E_1E_2)$ met $E_1$ en $E_2$ reguliere expressies over $\Sigma$
  \item $(E_1)^*$ met $E_1$ een reguliere expressie over $\Sigma$
  \item $(E_1|E_2)$ met $E_1$ en $E_2$ reguliere expressies over $\Sigma$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een reguliere expressie $E$ over een alfabet $\Sigma$ bepaalt een taal $L_E$ over $\Sigma$}
  Een taal bepaalt door een reguliere expressie is een reguliere taal.
  \begin{itemize}
  \item Als $E = \epsilon$, dan $L_E = \{\epsilon\}$
  \item Als $E = \phi$, dan $L_E = \emptyset$
  \item Als $E = a$ met $a \in \Sigma$, dan $L_E = \{a\}$
  \item Als $E = (E_1E_2)$, dan $L_E = L_{E_1}L_{E_2}$
  \item Als $E = (E_1)^*$, dan $L_E = L_{E_1}^*$
  \item Als $E = (E_1|E_2)$, dan $L_E = L_{E_1} \cup L_{E_2}$
  \end{itemize}
\end{definitie}

\begin{definitie}{De verzameling $RegLan$ van de reguliere talen}
  $RegLan$ is een verzameling die alle reguliere talen bevat. \\
  \\ $RegLan \subseteq L_\Sigma$
  \\ $x \in RegLan \Rightarrow x \in L_\Sigma$
  \\ $x \in RegLan \en y \in x \Rightarrow y \in \sstar$
\end{definitie}

% TODO (Optional): Bewijs dat RegLan een subalgebra is van L_Sigma

\subsection{NFA}

\begin{definitie}{Een niet-deterministische eindige toestandsautomaat}
  Een niet-deterministische eindige toestandsautomaat (NFA) is een 5-tal ($Q$, $\Sigma$, $\delta$, $q_s$, $F$):
  \begin{itemize}
  \item $Q$ is een eindige verzameling toestanden
  \item $\Sigma$ is een eindig alfabet
  \item \bm{$\delta : Q \times \Sigma_\epsilon \rightarrow \powerset(Q)$}\\$\delta$ is de overgangsfunctie
  \item $q_s \in Q$ is de starttoestand
  \item $F \subseteq Q$ is de verzameling van eindtoestanden
  \end{itemize}
\end{definitie}

Eigenschappen van een NFA:
\begin{itemize}
\item Een NFA is een gerichte graaf.
\item Elke knoop van een NFA heeft een label.
\item Knopen met een dubbele cirkel zijn eindtoestanden.
\item Lussen (bogen van een knoop naar zichzelf) zijn toegestaan in een NFA.
\item Boven van een NFA dragen een label met \'e\'en of meerdere symbolen uit het alfabet, gescheiden door een komma en/of $\epsilon$.
\item Er komt slechts \'e\'en boog aan in de starttoestand, die niet vertrekt vanuit een knoop.
\end{itemize}

% TODO: Uitvoering NFA
% TODO: Algebra van NFA's beschrijven

\begin{definitie}{Een string $s$ wordt aanvaard door een NFA}
  Een string $s$ ($a_1a_2a_3...a_n$ met $a_i \in \Sigma_\epsilon$) wordt aanvaard door een NFA ($Q$, $\Sigma$, $\delta$, $q_s$, $F$) als een rij toestanden $t_1t_2t_3...t_{n+1}$ bestaat zodanig dat:
  \begin{itemize}
  \item $t_1 = q_s$
  \item $t_{i+1} \in \delta(t_i, a_i)$
  \item $t_{n+1} \in F$
  \end{itemize}
\end{definitie}

\begin{definitie}{Een taal bepaald door een NFA $M$}
  Een taal $L$ wordt bepaald door een NFA $M$ als $M$ elke string van $L$ aanvaardt. Deze taal noteren we als $L_M$.
\end{definitie}

\begin{definitie}{Equivalente NFA's}
  Twee NFA's zijn equivalent als ze dezelfde taal bepalen.
\end{definitie}

% TODO: Transitietabel

Elke NFA beschrijft een reguliere taal en elke reguliere taal kan beschreven worden door een NFA ($L_E = L_{NFA_E}$). Figuur \ref{fig:regexnfa} toont de overgangen van de elementaire reguliere expressies naar de bijhorende NFA's.

\begin{figure}[ht]
\label{fig:regexnfa}
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{10cm}}
$E$ & $NFA_E$ \\ \hline
$\epsilon$ & \begin{nfa}
  \node[initial,state,accepting] (A) {};
  \addvmargin{1mm}
\end{nfa} \\
$\phi$ & \begin{nfa}
  \node[initial,state] (A) {};
  \addvmargin{1mm}
\end{nfa} \\
$a \in \Sigma$ & \begin{nfa}
  \node[initial,state]   (A)              {};
  \node[state,accepting] (B) [right of=A] {};
  \path (A) edge [] node {$a$} (B);
  \addvmargin{1mm}
\end{nfa} \\
$(E_1|E_2)$ & \begin{nfa}
  \node[initial,state]   (A)                    []                                     {};
  \node[]                (B)                    [above right=.25cm and .5cm of A,draw] {$NFA_1$};
  \node                  (C)                    [below right=.25cm and .5cm of A,draw] {$NFA_2$};
  \node[state]           (D)                    [right of=B]                           {};
  \node[state]           (E)                    [right of=C]                           {};
  \node[state,accepting] (F) at ($(C)!0.5!(D)$) [right=3.7cm of A]                     {};
  
  \path (A) edge [bend left]  node               {$\epsilon$} (B)
            edge [bend right] node [below left]  {$\epsilon$} (C)
        (B) edge []           node               {}           (D)
        (C) edge []           node               {}           (E)
        (D) edge [bend left]  node               {$\epsilon$} (F)
        (E) edge [bend right] node [below right] {$\epsilon$} (F);
  \addvmargin{1mm}
\end{nfa} \\
$(E_1E_2)$ & \begin{nfa}
  \node[initial]         (A) [draw]            {$NFA_1$};
  \node[state]           (B) [right of=A]      {};
  \node                  (C) [right of=B,draw] {$NFA_2$};
  \node[state,accepting] (D) [right of=C]      {};
  
  \path (A) edge [] node {}           (B)
        (B) edge [] node {$\epsilon$} (C)
        (C) edge [] node {}           (D);
  \addvmargin{1mm}
\end{nfa} \\
$(E_1)^*$ & \begin{nfa}
  \node[initial,state]   (A)                   {};
  \node                  (B) [right of=A,draw] {$NFA_1$};
  \node[state]           (C) [right of=B]      {};
  \node[state,accepting] (D) [right of=C]      {};
  
  \path (A) edge []           node         {$\epsilon$} (B)
            edge [bend right] node [above] {$\epsilon$} (C)
        (B) edge []           node         {$\epsilon$} (C)
        (C) edge []           node         {}           (D)
            edge [bend right] node [above] {$\epsilon$} (A);
  \addvmargin{1mm}
\end{nfa} \\
\end{tabular}
\caption{De overgang van een reguliere expressie naar een NFA.}
\end{figure}

\subsection{GNFA}

Een NFA kan omgezet worden naar reguliere expressie door de NFA eerst om te zetten naar een GNFA, vervolgens een GNFA met twee toestanden, waaruit de reguliere expressie rechstreeks af te lezen is.

\begin{definitie}{Een gegeneraliseerde NFA}
  \label{def:gnfa}
  Een gegeneraliseerde NFA (GNFA) is een NFA met gewijzigde en extra eigenschappen:
  \begin{itemize}
  \item Er is slechts \'e\'en eindtoestand die verschilt van de begintoestand.
  \item Er komen geen bogen aan in de starttoestand (vanuit andere toestanden) en vanuit de starttoestand vertrekt exact \'e\'en boog naar elke andere toestand.
  \item Er is exact \'e\'en boog van elke toestand naar de eindtoestand.
  \item Tussen elk paar toestanden is er exact \'e\'en boog in beide richtingen.
  \item Er is exact \'e\'en boog van elke toestand naar zichzelf.
  \item Het label van elke boog is een reguliere expressie.
  \end{itemize}
\end{definitie}

\begin{algoritme}{Uitvoering van een GNFA}
  \vspace{-5mm}\begin{enumalgo}
  \item Je start een GNFA met een string $s$.
  \item Je kiest een overgang naar een volgende toestand en verwijder de eerste $n$ symbolen die voldoen aan de reguliere expressie op de gevolgde boog. Bij een boog met enkel $\epsilon$ moet er geen symbool verwijderd worden en het is niet toegestaan om een boog te volgen met als label $\phi$.
  \item Als je aankomt in de eindtoestand en de string is leeg, dan heeft de GNFA de string $s$ aanvaard.
  \end{enumalgo}
\end{algoritme}

\begin{algoritme}{Transformatie NFA naar GNFA}
  \vspace{-5mm}\begin{enumalgo}
  \item Generaliseer de NFA:
    \begin{itemize}
    \item Voer een nieuwe starttoestand $q_s$ in.
    \item Voer een nieuwe (unieke) eindtoestand $q_a$ in.
    \item Teken $\epsilon$-boog van $q_s$ naar de oude begintoestand.
    \item Teken $\epsilon$-boog van elke oude eindtoestand naar $q_e$.
    \item Vul de automaat aan met $\phi$-bogen waar er bogen ontbreken. (Zie definitie \ref{def:gnfa})
    \item Neem parallelle gerichte bogen samen met de unie van hun labels.
    \end{itemize}
  \item Reduceer de GNFA:
    \begin{itemize}
    \item Als $Q \setminus \{q_s, q_e\} = \emptyset$, ga naar stap 3.
    \item Voer een reductiestap uit door een willekeurige knoop $q \in Q \setminus \{q_s, q_e\}$ te verwijderen. (Zie voorbeeld \ref{ex:gnfa})
    \item Herhaal stap 2.
    \end{itemize}
  \item Bepaal de reguliere expressie die af te lezen is als label op de boog tussen $q_s$ en $q_e$.
\end{enumalgo}
\end{algoritme}

% TODO: Bewijs dat elke string die aanvaard wordt voor de reductiestap nadien nog steeds aanvaard wordt
% TODO: Bewijs dat elke string die verworpen wordt voor de reductiestap nadien nog steeds verworpen wordt

\subsection{DFA}

\begin{definitie}{Een deterministische eindige toestandsautomaat}
  \label{def:dfa}
  Een deterministische eindige toestandsautomaat (DFA) is een type automaat dat gelijkt op een NFA, waarvoor de volgende extra eigenschappen gelden:
  \begin{itemize}
  \item Er zijn geen bogen met $\epsilon$.
  \item Elk symbool $a \in \Sigma$ mag hoogstens op \'e\'en uitgaande boog staan per knoop.
  \end{itemize}
\end{definitie}

\begin{definitie}{Een complete DFA}
  \label{def:cdfa}
  Een DFA is compleet wanneer de overgangsfunctie $\delta$ totaal is. D.w.z. dat voor elke $a \in \Sigma$ een overgang mogelijk is vanuit elke toestand. Definitie \ref{def:dfa} beschrijft een parti\"ele DFA. Een parti\"ele (niet-complete) DFA kan omgevormd worden tot een complete DFA door een extra toestand $q_t$ toe te voegen waar alle niet-acceptabele strings in vast komen te zitten. We bepalen een nieuwe overgangsfunctie $\delta'$ voor $Q' = Q \cup \{q_t\}$:
  \begin{equation*}
  \forall q \in Q', a \in \Sigma: \delta'(q, a) = \begin{cases}
    \delta(q, a), & \text{als}\ \delta(q, a) \neq \phi\\
    q_t & \text{anders}
  \end{cases}
  \end{equation*}
\end{definitie}

Definitie \ref{def:cdfa} impliceert ook dat voor elke $a \in \Sigma$ een overgang bestaat van $q_t$ naar $q_t$, waarin $t$ staat voor ``trash".

De complete DFA wordt voornamelijk gebruikt in praktijk. Verder in dit document wordt vaak gebruik gemaakt van een DFA met de assumptie dat $\delta$ een totale functie is. Daarbij wordt impliciet gesteld dat voor een niet-complete DFA eerst de constructie van de equivalente complete DFA wordt uitgevoerd.

\begin{algoritme}{Transformatie NFA naar DFA}
  \label{alg:nfadfa}
  We construeren een DFA ($Q_d$, $\Sigma$, $\delta_d$, $q_{sd}$, $F_d$) uit een NFA ($Q_n$, $\Sigma$, $\delta_n$, $q_{sn}$, $F_n$) zodanig dat $L_{NFA} = L_{DFA}$ als volgt:
  \begin{itemize}
  \item $Q_d = \powerset(Q_n)$: Elke toestand van de DFA is een verzameling van toestanden van de NFA. Onbereikbare toestanden zullen we later verwijderen, waardoor zal gelden: $Q_d \subseteq \powerset(Q_n)$.
  \item \bm{$\delta_d: (\powerset(Q_n) \times \Sigma) \rightarrow \powerset(Q_n)$}\\$\delta_d(\dfastate, a) = eb(\delta_n(\dfastate, a))$ voor $\dfastate \in Q_d$: Voor een symbool $a$ is er vanuit de toestand van de DFA $\dfastate$ een overgang naar de toestand van de DFA die alle toestanden van de NFA bevat die epsilon-bereikbaar zijn vanuit alle $q \in \dfastate$.
  \item $q_{sd} = eb(q_{sn})$: De starttoestand is de verzameling van toestanden van de NFA die epsilon-bereikbaar zijn vanuit de starttoestand van de NFA.
  \item $F_d = \{S|S \in Q_d, S \cap F_n \neq \emptyset\}$: Een eindtoestand van een DFA bevat altijd een eindtoestand van de NFA.
  \end{itemize}
  Om de constructie uit te voeren hebben we de volgende definities ingevoerd:
  \begin{itemize}
  \item \bm{$eb: Q_n \rightarrow \powerset(Q_n)$}\\ $eb(q) = \{x|x \in \{q\} \cup \delta_n(q, \epsilon)\}$ met $q \in Q_n$: De afbeelding die een toestand $q \in Q_n$ afbeeldt op alle epsilon-bereikbare toestanden. Een toestand $q_{next}$ is epsilon-bereikbaar uit $q$ indien $q_{next} = q$ of er een overgang bestaat zodanig dat $\delta_n(q, \epsilon) = q_{next}$.
  \item \bm{$eb: Q_d \rightarrow \powerset(Q_n)$}\\ $eb(\dfastate) = \{x|x \in \bigcup_{q \in \dfastate}eb(q)\}$ met $\dfastate \in Q_d$: De afbeelding die een toestand $\dfastate \in Q_d$ afbeeldt op alle toestanden die epsilon-bereikbaar zijn vanuit alle toestanden in $\dfastate$.
  \item \bm{$\delta_n: Q_d \times \Sigma \rightarrow \powerset(Q_n)$}\\ $\delta_n(\dfastate, a) = \{x|x \in \bigcup_{q \in \dfastate}\delta_n(q, a)\}$ met $\dfastate \in Q_d$ en $a \in \Sigma$: De afbeelding die een toestand $\dfastate \in Q_d$ afbeeldt op de verzameling van alle toestanden die voor een gegeven symbool bereikbaar zijn vanuit elke toestand in $\dfastate$.
  \end{itemize}
\end{algoritme}

Elke reguliere taal wordt bepaald door een DFA, omdat elke reguliere taal wordt bepaald door een NFA en elke NFA kan worden omgezet tot een DFA.

\begin{definitie}{De overgangsfunctie $\delta^*$ van een DFA voor strings}
  \label{def:deltaster}
  \bm{$\delta^*: (\powerset(Q) \times \sstar) \rightarrow \powerset(Q)$}\\
  $\delta^*$ is een afbeelding die een string afbeeldt op een verzameling toestanden die vanuit een toestand bereikt kunnen worden met die string. We defini\"eren $\delta^*$ inductief:
  \begin{equation*}
    \delta^*(q, s) = \begin{cases}
      q, & \text{als}\ s=\epsilon \\
      \delta^*(\delta(q, a), w) & \text{als}\ s=aw\ \text{voor}\ a \in \Sigma, w \in \sstar
    \end{cases}
  \end{equation*}
\end{definitie}

\begin{bewijs}{We bewijzen dat $\delta^*(q, wa) = \delta(\delta^*(q, w), a)$ voor $a \in \Sigma, w \in \sstar_\epsilon$.}
  Bewijs met inductie op basis van definitie \ref{def:deltaster}:
  \begin{itemize}
  \item Stel $w = \epsilon$, dan geldt:\\$\delta^*(q, \epsilon a) = \delta^*(q, a \epsilon) = \delta^*(\delta(q, a), \epsilon) = \delta(q, a) = \delta(\delta^*(q, \epsilon), a)$
  \item Stel $w \neq \epsilon$ en $w = bw'$ met $b \in \Sigma, w' \in \sstar_\epsilon$, dan geldt:\\$\delta^*(q, wa) = \delta^*(q, bw'a) = \delta^*(\delta(q, b), w'a) = \delta(\delta^*(\delta(q, b), w'), a) = \delta(\delta^*(q, w), a)$
  \end{itemize}
\end{bewijs}

\subsection{Minimale DFA}

\begin{definitie}{f-gelijke toestanden}
  Twee toestanden zijn finaal-gelijk indien
  \vspace{-3mm}\begin{equation*}
  \forall w \in \sstar : \delta^*(p, w) \in F \Leftrightarrow \delta^*(q, w) \in F
  \end{equation*}
\end{definitie}

\begin{definitie}{f-verschillende toestanden}
  Twee toestanden zijn finaal-verschillend indien ze niet f-gelijk zijn.
\end{definitie}

Een minimale DFA wordt opgesteld door f-gelijke toestanden samen te nemen. Om het minimaliseren te vergemakkelijken stellen we een totale functie  $\delta'$ op van $\delta$ waarbij in elke toestand voor elk ontbrekend symbool uit het alfabet een overgang wordt toegevoegd zodanig dat $\delta'(q_i, a)=q_i$.

% TODO: Algoritme minimale DFA
% TODO: Bewijs minimale DFA heeft minimaal aantal toestanden
% TODO: Isomorfe DFA's

\subsection{Myhill-Nerode relaties op $\sstar$}

\begin{definitie}{$\partition_1$ is fijner dan $\partition_2$}
  Als een partie $\partition_1$ fijner is dan een $\partition_2$, dan zit elk element van $\partition_1$ vervat in een element van $\partition_2$. $\{\partition_1$, $\partition_2\}$ vormt een tralie waar geldt dat $\partition_1 \leq \partition_2$.
\end{definitie}

\begin{definitie}{$\partition_1$ is groffer dan $\partition_2$}
  Als een partitie $\partition_1$ groffer is dan een $\partition_2$, dan zit elk element van $\partition_2$ vervat in een element van $\partition_1$. $\{\partition_2$, $\partition_1\}$ vormt een tralie waar geldt dat $\partition_2 \leq \partition_1$.
\end{definitie}

\begin{definitie}{Equivalentierelatie $\sim_L$ over $\sstar$}
  Gegeven een taal $L$ over $\Sigma$, is het mogelijk om $\sstar$ op te delen in de partitie $\{L,\overline{L}\}$. De equivalentierelatie $\sim_L$ over $\sstar$ beschouwt twee elementen van $\sstar$ gelijkwaardig indien ze beiden tot dezelfde deelverzameling van die partitie behoren.
  \begin{equation*}
  \forall x, y \in \sstar: x \sim_L y \Leftrightarrow x,y \in L \of x,y \notin L
  \end{equation*}
\end{definitie}

\begin{definitie}{De deelverzameling $reach(q)$ van $\sstar$ voor een DFA}
  De deelverzameling $reach(q)$ van $\sstar$ voor een DFA ($Q$, $\Sigma$, $\delta$, $q_s$, $F$) bevat alle strings die je vanaf de begintoestand $q_s$ in de toestand $q \in Q$ brengen.
  \begin{equation*}
  reach(q) = \{s \in \sstar|\delta^*(q_s,s)=q\}
  \end{equation*}
\end{definitie}

\begin{definitie}{Equivalentierelatie $\sim_{DFA}$ over $\sstar$}
  Gegeven een $DFA$ met $L_{DFA}$ een taal over $\Sigma$, is het mogelijk om $\sstar$ op te delen in de een partitie $\{reach(q)|q \in Q\}$ zodanig dat
  \begin{itemize}
  \item de partitie eindig is.
  \item $s \in \sstar$ wordt aanvaard door de $DFA$ alss $s \in reach(q)$ voor $q \in F$.
  \item als $s \in reach(q)$ dan $\forall a \in \Sigma : sa \in reach(\delta(q, a))$.
  \end{itemize}
  Of in symbolen:
  \begin{equation*}
  \forall x, y \in \sstar: x \sim_{DFA} y \Leftrightarrow \delta^*(q_s, x) = \delta^*(q_s, y)
  \end{equation*}
\end{definitie}

De equivalentierelatie $\sim_{DFA}$ is een $MN(L_{DFA})$-relatie op $\sstar$.

\begin{definitie}{Een Myhill-Nerode relatie voor een taal $L$ over $\sstar$}
  \label{def:mnl}
  Een Myhill-Nerode relatie voor een taal $L$ ($MN(L)$-relatie) is een equivalentierelatie $\sim_X$ die voldoet aan de volgende eigenschappen:
  \begin{itemize}
  \item $\sim_X$ is rechts congruent\\$\forall x, y \in \sstar, a \in \Sigma: x \sim_X y \Rightarrow xa \sim_X ya$
  \item $\sim_X$ verfijnt $\sim_L$\\$x \sim_X y \Rightarrow x \sim_L y$
  \item $\sim_X$ heeft een eindige index\\Het aantal equivalentieklassen van $\sim_X$ is eindig.
  \end{itemize}
\end{definitie}

\begin{bewijs}{We bewijzen dat een $MN(L)$-relatie enkel bestaat alss de taal $L$ regulier is.}
  \input{bewijzen/mnlregulier}
\end{bewijs}

% TODO: MN(L) en isomorfe DFA's
% TODO: Supremum van MN(L)-relaties

Het is mogelijk om met een $MN(L)$-relatie te bewijzen dat een taal niet-regulier is. Je gaat te werk door aan te nemen dat als er een minimale DFA bestaat voor de taal, waarvoor men een relatie $\sim_{DFA}$ definieert. Je neemt aan dat die voldoet aan de eerste twee eigenschappen van de definitie (\ref{def:mnl}) en bewijst vervolgens dat het aantal equivalentieklassen van die relatie oneindig is.

% TODO: Stelling van Myhill en Nerode

\subsection{Pompend lemma voor reguliere talen}

Het pompend lemma kan niet gebruikt worden om te bewijzen dat een taal regulier is. Elke reguliere taal moet voldoen aan de eigenschappen van het pompend lemma, maar er zijn ook niet-reguliere talen die daaraan voldoen. Daardoor kan je met zekerheid zeggen dat een taal niet-regulier is als je ze niet kan pompen, maar je kan niet met zekerheid zeggen dat een taal regulier is. In FO-logica $Regulier(L) \rightarrow KanPompen(L)$ met waarheidstabel:
\begin{center}
\begin{tabular}{r|c|c}
                     & $KanPompen(L)$ & $\neg KanPompen(L)$ \\ \hline
  $Regulier(L)$      & True           & False               \\ \hline
  $\neg Regulier(L)$ & True           & True
\end{tabular}
\end{center}

\begin{definitie}{Het pompend lemma voor reguliere talen}
  Voor een reguliere taal $L$ bestaat een pomplengte $d$ zodanig dat als $s \in L$ en $|s| \geq d$, er minstens \'e\'en verdeling bestaat van $s$ in stukken $x$, $y$ en $z$ met $s = xyz$ en
  \begin{enumerate}
  \item $\forall i \geq 0: xy^iz \in L$
  \item $|y| > 0$
  \item $|xy| \leq d$
  \end{enumerate}
\end{definitie}

\begin{bewijs}{We bewijzen de eigenschappen van het pompend lemma.}
  Voor een DFA die een taal $L$ bepaalt nemen we een pomplengte $d = \#Q + 1$ en een willekeurige string $s = a_1a_2a_3...a_n$ met $n \geq d$. De accepterende sequentie van toestanden ($q_s = q_1$, $q_2$, ..., $q_f$) voor s heeft een lengte strikt groter dan het aantal toestanden in $Q$, dus er zijn bij de eerste $d$ toestanden zeker twee toestanden gelijk omdat er maar $d-1$ toestanden zijn. Stel dat $q_i$ en $q_j$ gelijk zijn met $i < j \leq d$, dan nemen we
  \begin{equation*}
  \begin{cases}
  x = a_1a_2...a_i\\
  y = a_{i+1}a_{i+2}...a_j\\
  z = a_{j+1}a_{j+2}...a_n
  \end{cases}
  \end{equation*}
  \begin{itemize}
  \item Eigenschap 1 geldt omdat $y$ een lus volgt en die $k$ keer herhaald kan worden voor $xy^kz \in L$.
  \item Eigenschap 2 geldt omdat $i$ strikt kleiner is dan $j$, dus bevat $y$ minstens \'e\'en element.
  \item Eigenschap 3 geldt omdat $i < j \leq d$, dus we hebben $xy$ kleiner dan (of gelijk aan) $d$ gekozen.
  \end{itemize}
\end{bewijs}

% TODO: Voorbeeld gebruiken van pompend lemme of aan te tonen dat een taal niet-regulier is
% TODO: Algebra van DFAs

\subsection{Andere automaten}

\begin{definitie}{B\"uchi automaat}
  Een B\"uchi automaat (BA) is een automaat die lijkt op een NFA, maar deze doorlopen oneindige strings. Een BA accepteert een string indien de rij toestanden die gepasseerd wordt oneindig dikwijls een accepterende toestand bevat.
\end{definitie}

\newpage\section{Contextvrije talen}

\begin{definitie}{Contextvrije grammatica}
  Een contextvrije grammatica (CFG) is een 4-tal ($V$, $\Sigma$, $R$, $S$) waarbij
  \begin{itemize}
  \item $V$ een eindige verzameling niet-eindsymbolen is (variabelen of non-terminals)
  \item $\Sigma$ een eindig alfabet van eindsymbolen (terminals), disjunct met $V$
  \item $R$ een eindige verzameling regels (producties) is die bestaan uit een koppel van een variabele en een string $s \in \sstar_\epsilon$, gescheiden door $\rightarrow$
  \item $S \in V$ is de starttoestand
  \end{itemize}
\end{definitie}

\begin{definitie}{Afleiding/constructie m.b.v. een CFG}
  Gegeven een CFG ($V$, $\Sigma$, $R$, $S$) en een string $f$ over $V \cup \Sigma_\epsilon$, dan kan men een string $b$ over $V \cup \Sigma_\epsilon$ afleiden/construeren uit $f$ ($b \Rightarrow^* f$) met de gegeven CFG, indien er er een rij strings $s_0,s_1,s_2,...,s_n$ bestaat zodanig dat
  \begin{itemize}
  \item $s_0 = b$
  \item $s_n = f$
  \item $s_{i+1}$ is gelijk aan $s_i$ (met $i < n$) waarin een variabele $X$ wordt vervangen door de rechterzijde van een productie waarin $X$ aan de linkerzijde voorkomt.
  \end{itemize}
\end{definitie}

\begin{definitie}{Taal $L_{CFG}$ bepaald door een CFG}
  Een taal $L_{CFG}$ bepaald door een CFG ($V$, $\Sigma$, $R$, $S$) is een verzameling van strings over $\Sigma$ die kan afgeleid worden uit het startsymbool $S$.
  \begin{equation*}
  L_{CFG} = \{s \in \sstar|S \Rightarrow^* s\}
  \end{equation*}
\end{definitie}

\begin{definitie}{Contextvrije taal}
  Een taal $L$ is een contextvrije taal (CFL) indien er een CFG bestaat zodanig dat $L = L_{CFG}$.
\end{definitie}

\begin{definitie}{Ambigue strings}
  Een string is ambigu indien er voor die meerdere meest-linkse (of meest-rechtse) afleidingen bestaan.
\end{definitie}

\begin{definitie}{Ambigue CFG's}
  Een CFG is ambigu indien er strings $s \in L_{CFG}$ die ambigue zijn t.o.v. de CFG.
\end{definitie}
Sommige CFL's hebben niet-ambigue CFG, maar dat geldt niet voor elke CFL. Een CFL die geen niet-ambigue CFG heeft is inherent ambigu.

\begin{definitie}{Equivalente CFG's}
  Twee CFG's zijn equivalent indien ze dezelfde taal bepalen.
  \begin{equation*}
  L_{CFG_1} = L_{CFG_2}
  \end{equation*}
\end{definitie}

\begin{definitie}{Chomsky Normaal Vorm}
  \label{def:cnf}
  Elke CFG heeft een Chomsky Normaal Vorm (CNF) die dezelfde taal genereert en waarbij de producties een beperkt aantal vormen kan aannemen:
  \begin{itemize}
  \item $A \rightarrow BC$ met $\begin{cases}A \in V \\ B,C \in V \setminus \{S\}\end{cases}$
  \item $A \rightarrow \alpha$ met $\begin{cases}A \in V \\ \alpha \in \Sigma\end{cases}$
  \item $S \rightarrow \epsilon$
  \end{itemize}
\end{definitie}

Met de CNF
\begin{itemize}
\item kan je onmiddellijk zien of $L_{CFG}$ de lege string bevat.
\item is elke parse tree (bijna) een volledige binaire boom.
\item heeft de afleiding van een string van lengte $n > 0$ altijd een lengte $2n-1$.
\end{itemize}

% TODO: Bewijs CNF

\begin{definitie}{Greibach Normaal Vorm}
  Elke CFG heeft een Greibach Normaal Vorm (GNF) die dezelfde taal genereert en waarbij de producties een beperkt aantal vormen kan aannemen:
  \begin{itemize}
  \item $A \rightarrow \alpha X$ met $\begin{cases}A \in V \\ \alpha \in \Sigma \\ X = X_1X_2X_3...X_n \text{ met } X_i \in V, n \in \nat\end{cases}$
  \item $S \rightarrow \epsilon$
  \end{itemize}
\end{definitie}

\subsection{PDA}

\begin{definitie}{Push-down automaat}
  Een push-down automaat (PDA) is een 6-tal ($Q$, $\Sigma$, $\Gamma$, $\delta$, $q_s$, $F$) waarbij
  \begin{itemize}
  \item $Q$ is een eindige verzameling toestanden
  \item $\Sigma$ is een eindige inputalfabet
  \item $\Gamma$ is een eindige stapelalfabet
  \item \bm{$\delta: Q \times \Sigma_\epsilon \times \Gamma_\epsilon \rightarrow \powerset(Q \times \Gamma_\epsilon)$}\\$\delta$ is een overgangsfunctie
  \item $q_s$ is de starttoestand
  \item $F \subseteq Q$ is een verzameling eindtoestanden
  \end{itemize}
\end{definitie}

\begin{figure}[!ht]
  \label{fig:pdasstep}
  \centering
  \begin{pda}
  \node[state] (A) []               {};
  \node[state] (B) [right=3cm of A] {};
  
  \path (A) edge [] node {$\alpha,\beta\rightarrow\gamma$} (B);
  \addvmargin{1mm}
  \end{pda}
  \caption{Een overgang van een PDA.}
\end{figure}

\begin{nobreakparagraph}
Een PDA maakt overgangen zoals in figuur \ref{fig:pdasstep},
\begin{itemize}
\item indien $\alpha$ het eerste symbool is van de string
\item en $\beta$ bovenaan de stapel staat,
\item je kan die boog volgen en
\begin{itemize}
\item $\alpha$ van de string verwijderen
\item $\beta$ van de stapel verwijderen
\item $\gamma$ op de stapel plaatsen
\end{itemize}
\end{itemize}
\end{nobreakparagraph}
Indien de PDA niet-deterministisch is, kunnen er meerdere bogen met dezelfde $\alpha,\beta$ combinaties vertrekken uit een toestand.

% TODO: Aanvaarding van een string door een PDA

Alternatieve definities van een PDA:
\begin{itemize}
\item Er mag meer dan \'e\'en symbool op de stapel geplaatst worden tijdens een overgang.
\item Een string wordt geaccepteerd indien de string op is en de stapel leeg is ($F$ heeft geen belang).
\item Een string wordt geaccepteerd indien de string op is, de stapel leeg is en we in een eindtoestand zitten.
\item In een overgang wordt een symbool op de stapel geplaatst maar er wordt geen symbool van de stapel verwijderd of omgekeerd.
\item Er is slechts \'e\'en eindtoestand.
\end{itemize}
Voor een CFL is het mogelijk om met eender welke van deze definities equivalente automaten te maken.

% TODO: Bewijs equivalentie CFG en PDA

\begin{algoritme}{Constructie van een PDA uit een CFG}
  \label{alg:cfgpda}
  We stellen een PDA ($Q$, $\Sigma_{PDA}$, $\Gamma$, $\delta$, $q_s$, $F$) voor een CFG ($V$, $\Sigma_{CFG}$, $R$, $S$) met
  \begin{itemize}
  \item $Q = {q_s, q_h, q_a}$ met $q_h$ een hulptoestand
  \item $\Sigma_{PDA} = \Sigma_{CFG}$
  \item $\Gamma = \{\$\} \cup V \cup \Sigma_{CFG}$
  \item $\delta$ waarvoor geldt:
  \begin{itemize}
  \item Er is 1 boog van $q_s$ naar $q_h$ met label ``$\epsilon,\epsilon\rightarrow\$$".
  \item Er is 1 boog van $q_h$ naar $q_a$ met label ``$\epsilon,\$\rightarrow\epsilon$".
  \item Voor elk symbool $a \in \Sigma_{CFG}$ is er een lus bij $q_h$ met label ``$a,a\rightarrow\epsilon$".
  \item Voor elke productie $(X \rightarrow \gamma) \in R$ is er een lus bij $q_h$ met label ``$\epsilon,X\rightarrow\gamma$". (Vervang de linkerkant van een productie bovenaan de stapel met de rechterkant van de productie.)
  \end{itemize}
  \item $q_s$ de starttoestand
  \item $F = \{q_a\}$ met $q_a$ de eindtoestand
  \end{itemize}
\end{algoritme}

Om een meest-linkse afleiding te bekomen moeten we in algoritme \ref{alg:cfgpda} de symbolen van een string $\gamma \in \sstar_\epsilon$ in omgekeerde volgorde op de stapel plaatsen.

% TODO: Een PDA accepteert een L_CFG
% TODO: Constructie CFG uit PDA

\subsection{Pompend lemma voor contextvrije talen}

\begin{definitie}{Het pompend lemma voor contextvrije talen}
  Voor een contextvrije taal $L$ bestaat een pomplengte $d$ zodanig dat als $s \in L$ en $|s| \geq d$, er minstens \'e\'en verdeling van $s$ bestaat in stukken $u$, $v$, $x$, $y$, $z$ met $s = uvxyz$ en
  \begin{enumerate}
  \item $\forall i \geq 0: uv^ixy^iz \in L$
  \item $|vy| > 0$
  \item $|vxy| \leq d$
  \end{enumerate}
\end{definitie}

Net zoals bij het pompend lemma voor reguliere talen, is het niet mogelijk om met deze variant te bewijzen dat een taal regulier is, omdat het een eigenschap is van een CFL, maar er zijn ook niet-contextvrije talen die die eigenschap zouden kunnen hebben. Het is enkel mogelijk om aan te tonen dat als deze eigenschap niet geldig is, dat een taal niet contextvrij is.

\begin{bewijs}{We bewijzen het pompend lemma voor contextvrije talen.}
  Voor een taal $L$ nemen we een CFG in CNF, waardoor er voor elke $s \in L$ een parse tree bestaat. Omdat de CFG in CNF staat, weten we dat elk blad onderaan de boom een terminal is, die (voor een niet-lege string $s$) volgt uit een productie met vorm ``$A \rightarrow \alpha$". Elke andere knoop in de boom moet dan volgen uit een productie met vorm ``$A \rightarrow BC$". Daarom kunnen we weggen dat indien we alle bladeren van de boom wegsnoeien, we een perfecte binaire boom bekomen, die een hoogte heeft van minstens $log_2|s|$.
  
  Het langste enkelvoudig pad vanaf de wortel van de parse tree moet minstens een lengte hebben van $log_2|s| + 1$. We nemen een string $s \in L$ waarvoor geldt dat $log_2|s| + 1 > n$ met $n = \#V + 1$ Dus er moet minstens \'e\'en variabele $X$ herhaald worden. Vanwege de definitie van de CNF (definitie \ref{def:cnf}) geldt dat $X \neq S$. We nemen op dat pad een $X_1$ en de dichtste herhaling $X_2$ (zie figuur \ref{fig:pumptree}). We kunnen nu de afleiding construeren als
  \begin{equation*}
  S \Rightarrow^* uX_2z \Rightarrow^* uvX_1yz \Rightarrow^* uvxyz \text{ met }u,v,x,y,z \in \sstar
  \end{equation*}
  
  \begin{itemize}
  \item Eigenschap 1 geldt omdat indien de bovenstaande afleiding geldt, de volgende afleidingen ook moeten gelden:
  \begin{equation*}
  S \Rightarrow^* uX_2z \Rightarrow^* uxz
  \end{equation*}
  \begin{equation*}
  S \Rightarrow^* uXz \Rightarrow^* uvXyz \Rightarrow^* uvvxyyz
  \end{equation*}
  \item Eigenschap 2 geldt omdat $v$ en $y$ niet tegelijkertijd leeg kunnen zijn, want dan zou men $X$ uit zichzelf kunnen afleiden en dat kan niet vanwege de vorm van de CFG.
  \end{itemize}
  
  Deze eigenschappen zijn geldig voor strings langer dan de pomplengte, dus $d = 2^{n-1}$.
  
  \begin{itemize}
  \item Eigenschap 3 geldt omdat $vxy$ afgeleid wordt uit een $X$ met een parse tree die lager is dan $n$, dus hoogstens $d$ bladeren heeft, wat juist correspondeert met $vxy$.
  \end{itemize}
\end{bewijs}

\begin{figure}[ht]
  \label{fig:pumptree}
  \centering
  \begin{tikzpicture}[-,
    >=stealth',
    shorten >=1pt,
    auto,
    node distance=1cm]
  \tikzstyle{every state}=[fill=none,draw=none,text=black]
  
  \node (S)                {$S$};
  \node (X2) [below of=S]  {$X_2$};
  \node (X1) [below of=X2] {$X_1$};
  \node (x)  [below of=X1] {$x$};
  \node (l3) [left of=x]   {};
  \node (v)  [left of=l3]  {$v$};
  \node (l2) [left of=v]   {};
  \node (u)  [left of=l2]  {$u$};
  \node (l1) [left of=u]   {};
  \node (l4) [right of=x]  {};
  \node (y)  [right of=l4] {$y$};
  \node (l5) [right of=y]  {};
  \node (z)  [right of=l5] {$z$};
  \node (l6) [right of=z]  {};
  
  \path (S)  edge []                   node {} (X2)
             edge [bend right]         node {} (l1)
             edge [bend left]          node {} (l6)
        (X2) edge [dotted]             node {} (X1)
             edge [dotted, bend right] node {} (l2)
             edge [dotted, bend left]  node {} (l5)
        (X1) edge [dotted]             node {} (X1)
             edge [dotted, bend right] node {} (l3)
             edge [dotted, bend left]  node {} (l4);
  \end{tikzpicture}
  \caption{De parse tree met de repeterende variabele $X$.}
\end{figure}

% TODO: Toepassing pompend lemma voor CFL
% TODO: Algebra van CFL's
% TODO: Ambiguiteit en DPDA
% TODO: Contextgevoelige grammatica

\newpage\section{Chomsky hi\"erarchie}

De Chomsky hi\"erarchie is een hi\"erarchische rangschikking van talen. Elke klasse van talen in de hi\"erarchie zit vervat in een sterkere klasse van talen, met de grootste klasse (die van de Turing-herkenbare talen) zijnde een deelverzameling van $L_\Sigma$:
\begin{itemize}
\item Type-0: De klasse van de herkenbare talen heeft een onbeperkte grammatica, dat wil zeggen er geen restricties zijn op de grammaticale regels. Elke taal die door een Turingmachine herkent wordt zit in deze klasse.
\item Type-1: De klasse van de contextgevoelige talen heeft een contextgevoelige grammatica, daarbij mogen de productieregels in tegenstelling tot een CFG zowel aan de linker- als rechterzijde een combinatie van variabelen en terminals bevatten. Elke taal die door een lineair begrensde automaat (Turingmachine) bepaalt wordt zit in deze klasse. Een LBA kan een beslissingsprobleem oplossen in $O(n)$-ruimte.
\item Type-2: De klasse van de contextvrije talen heeft een contextvrije grammatica (CFG). Elke taal die door een push-down automaat bepaalt wordt zit in deze klasse. Het parsen van een string uit een taal $L_{CFG}$ kan in $O(n^2)$-tijd.
\item Type-3: De klasse van de reguliere talen heeft een reguliere grammatica. Elke taal die door een eindige toestandsautomaat bepaalt wordt zit in deze klasse. Een string uit een taal $L_{RE}$ kan herkend worden in $O(n)$-tijd.
\end{itemize}

\begin{figure}[ht]
\centering
  \begin{tikzpicture}
  \path
    (0,0) rectangle (8,6) [draw]
    (1.5,5.5) node {$L_\Sigma = \powerset(\sstar)$}
    (4,2.75) coordinate (A) node[above=1.5cm] {Turing-herkenbare talen} ellipse (3.5 and 2.5) [draw]
    (4,2.25) coordinate (B) node[above=1cm] {Contextsensitieve talen} ellipse (3 and 2) [draw]
    (4,1.75) coordinate (C) node[above=0.5cm] {Contextvrije talen} ellipse (2.5 and 1.5) [draw]
    (4,1.25) coordinate (D) node {Reguliere talen} ellipse (2 and 1) [draw];
  \end{tikzpicture}
  \caption{Een voorstelling van de Chomsky-hi\"erarchy.}
\end{figure}

\newpage\section{Turingmachines}

\begin{definitie}{Turingmachine}
  \label{def:tm}
  Een Turingmachine (TM) is een 7-tal ($Q$, $\Sigma$, $\Gamma$, $\delta$, $q_s$, $q_a$, $q_r$) waarbij
  \begin{itemize}
  \item $Q$ een eindige verzameling toestanden
  \item $\Sigma$ een eindig invoer alfabet dat $\#$ niet bevat
  \item $\Gamma$ een eindig tape alfabet met $\# \in \Gamma$ en $\Sigma \subset \Gamma$
  \item $q_s$ de starttoestand
  \item $q_a$ de accepterende eindtoestand
  \item $q_r$ de verwerpende eindtoestand verschillend van $Q_a$
  \item \bm{$\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, S\}$}\\$\delta$ de (totale) transitiefunctie
  \end{itemize}
\end{definitie}

$\#$ wordt gebruikt om aan te geven dat een positie op de band van de TM nog niet beschreven is. We noemen dit het blanco symbool.

% TODO: Werking TM

\begin{definitie}{Opdeling van $\sstar$ door een TM}
  Een TM kan $\sstar$ in drie disjuncte stukken opdelen:
  \begin{itemize}
  \item $L_{TM}$: De taal met alle strings die door de TM worden geaccepteerd.
  \item $\infty_{TM}$: De taal met alle strings waarvoor de TM niet stopt.
  \item De resterende strings die door de TM worden verworpen.
  \end{itemize}
\end{definitie}

\begin{definitie}{(Turing-)herkenbaarheid}
  \vspace{-5mm}\begin{itemize}
  \item Een Turingmachine $TM$ herkent een taal $L_{TM}$.
  \item Een taal $L$ is herkenbaar indien er een Turingmachine $TM$ bestaat zodanig dat $L = L_{TM}$.
  \end{itemize}
\end{definitie}

\begin{definitie}{Co-herkenbaarheid}
  Een taal $L$ is co-herkenbaar indien $\overline{L}$ herkenbaar is.
\end{definitie}

\begin{definitie}{(Turing-)beslisbaarheid}
  \vspace{-5mm}\begin{itemize}
  \item Een Turingmachine $TM$ beslist een taal $L_{TM}$ indien $TM$ $L$ herkent en $\infty_{TM} = \emptyset$.
  \item Een taal $L$ is beslisbaar indien er een Turingmachine $TM$ bestaat zodanig die $L$ beslist.
  \item Een taal $L$ is beslisbaar indien ze herkenbaar en co-herkenbaar is.
  \end{itemize}
\end{definitie}

\begin{definitie}{Co-beslisbaarheid}
  Een taal $L$ die beslisbaar is is ook co-beslisbaar.
\end{definitie}

\begin{bewijs}{We bewijzen co-beslisbaarheid.}
  Als een beslisser $B$ de taal $L$ beslist, dan stopt die beslisser voor elke invoer bij de accepterende eindtoestand $q_a$ of de verwerpende eindtoestand $q_r$. We kunnen een beslisser $B'$ construeren voor $\overline{L}$ door bij $B$ de toestanden $q_a$ en $q_r$ om te wisselen. Omdat $B$ ook stopt voor alle strings die niet tot de taal behoren zal $B'$ die strings accepteren en alle strings die $B$ accepteert verwerpen. Bijgevolg is $\overline{L}$ beslisbaar.
\end{bewijs}

\begin{bewijs}{We bewijzen dat een taal beslisbaar is als ze herkenbaar en co-herkenbaar is.}
  Stel een machine $M_1$ herkent $L$ en een machine $M_2$ herkent $\overline{L}$. We construeren nu een machine $M$ die voor een string beide machines $M_1$ en $M_2$ laat lopen. Indien $M_1$ de string accepteert, dan accepteert $M$ de string. Indien $M_2$ de string accepteert, dan verwerpt $M$ de string. Omdat $M_1$ alle strings accepteert uit $L$ en $M_2$ alle strings uit $\overline{L}$, zal $M$ voor elke invoer stoppen in een eindtoestand. Bijgevolg is $M$ een beslisser voor $L$, dus is $L$ beslisbaar.
\end{bewijs}

Niet alle talen $L \in L_\Sigma$ zijn herkenbaar.
% TODO: Bewijs

% TODO: Grafische voorstelling Turingmachine
% TODO: Berkeningen van een TM voorstellen en nabootsen
% TODO: Deterministische Turinmachines
% TODO: Encodering
% TODO: Universele Turingmachine

\begin{definitie}{Het acceptatieprobleem voor TM's}
  Het acceptatieprobleem is de vraag of het mogelijk is om voor een gegeven Turingmachine $M$ en gegeven string $s$ te bepalen of $M$ $s$ accepteert.
  \begin{equation*}
  \atm = \{\langle M,s \rangle | M\text{ is een Turingmachine en }s \in L_M\}
  \end{equation*}
\end{definitie}

Er bestaat geen Turingmachine $B$ die kan beslissen of een gegeven Turingmachine $M$ een gegeven string $s$ accepteert. De taal $\atm$ is niet beslisbaar.

\begin{bewijs}{We bewijzen dat $\atm$ niet beslisbaar is.}
We bewijzen dit door contradictie. Stel dat er een beslisser $B$ bestaat voor $\atm$. Bij een input $\langle M,s \rangle$ accepteert $B$ $M$ als $M$ $s$ accepteert en $B$ verwerpt $M$ als $M$ $S$ verwerpt of blijft lopen.

We construeren nu een contradictiemachine $C$ als
\begin{equation*}
C(\langle M \rangle) = opposite(B(\langle M,M \rangle))\text{ voor elke Turingmachine M}
\end{equation*}
De functie $opposite(x)$ is gedefinieerd als
\begin{equation*}
opposite(x) = \begin{cases}
reject, & \text{ als } x = accept\\
accept & \text{ als } x = reject
\end{cases}
\end{equation*}

We nemen nu $C(\langle C \rangle) = opposite(B(\langle C,C \rangle))$:
Als $C(\langle C \rangle) = accept$ ($C$ accepteert $C$), dan accepteert de beslisser $B$ de invoer $\langle C,C \rangle$, dus $B(\langle C,C \rangle) = accept$. Maar $opposite(B(\langle C,C \rangle))$ is dan $reject$, dat is een tegenstelling omdat dan geldt $C(\langle C \rangle) \neq opposite(B(\langle C,C \rangle))$.

We kunnen nu zeggen dat de machine $C$ niet kan bestaan, dus de beslisser $B$ kan ook niet bestaan. Bij gevolg is $\atm$ niet beslisbaar.
\end{bewijs}

\begin{definitie}{Het Halting-probleem voor TM's}
  Het Halting-probleem is de vraag of het mogelijk is om voor een gegeven Turingmachine $M$ en gegeven string $s$ te bepalen of $M$ stopt bij de invoer van $s$ m.a.w. dat $M$ $S$ accepteert of verwerpt.
  \begin{equation*}
  \htm = \{\langle M,s \rangle | M\text{ is een Turingmachine die stopt bij invoer }s \in L_M\}
  \end{equation*}
\end{definitie}

\begin{bewijs}{We bewijzen dat $\htm$ niet beslisbaar is.}
Stel dat $\htm$ beslisbaar is door een beslisser $H$. We construeren nu een beslisser $B$ voor $\atm$ als volgt:

Bij een invoer $\langle M,s \rangle$ laat $B$ de machine $H$ lopen op $\langle M,s \rangle$.
\begin{itemize}
\item Indien $H(\langle M,s \rangle) = accept$, dan stopt $M$ voor een invoer $s$ (dus $M(s) = accept$ of $M(s) = reject$). $B$ geeft als resultaat $M(s)$.
\item indien $H(\langle M,s \rangle) = reject$, dan stopt $M$ niet voor een invoer $s$. $B$ geeft als resultaat $reject$.
\end{itemize}
Omdat $\atm$ niet beslisbaar is, kan $B$ niet bestaan, dus kan ook $H$ niet bestaan. Bij gevolg is $\htm$ niet beslisbaar.

We zeggen dat $\atm$ reduceerbaar is naar $\htm$.
\end{bewijs}

\begin{bewijs}{We bewijzen dat $\atm$ herkenbaar is.}
  Het is mogelijk een herkenner $H$ voor $\atm$ te construeren die bij een invoer $\langle M,s \rangle$ $M$ laat lopen op $s$. $H$ accepteert de invoer $\langle M,s \rangle$ als $M$ de invoer $s$ accepteert en verwerpt de invoer als $M$ niet stopt bij invoer $s$ of $s$ verwerpt.
\end{bewijs}

\begin{bewijs}{We bewijzen dat $\htm$ herkenbaar is.}
  Het is mogelijk een herkenner $H$ voor $\htm$ te construeren die bij een invoer $\langle M,s \rangle$ $M$ laat lopen op $s$. $H$ accepteert de invoer $\langle M,s \rangle$ als $M$ stopt bij invoer $s$ en verwerpt de invoer als $M$ niet stopt bij invoer $s$.
\end{bewijs}

\begin{bewijs}{We bewijzen dat $\overline{\atm}$ niet herkenbaar is.}
  Stel dat $\overline{\atm}$ herkenbaar is en we weten dat $\atm$ herkenbaar is. Dan volgt dat $\atm$ beslisbaar is, wat niet mogelijk is. Bij gevolg kan $\overline{\atm}$ niet herkenbaar zijn. 
\end{bewijs}

\begin{bewijs}{We bewijzen dat $\overline{\htm}$ niet herkenbaar is.}
  Stel dat $\overline{\htm}$ herkenbaar is en we weten dat $\atm$ herkenbaar is. Dan volgt dat $\htm$ beslisbaar is, wat niet mogelijk is. Bij gevolg kan $\overline{\htm}$ niet herkenbaar zijn. 
\end{bewijs}

\subsection{Enumeratormachine}

\begin{definitie}{Enumeratormachine}
  \input{definities/enum}
\end{definitie}

Een enumeratormachine produceert (enumereert) een verzameling strings op de outputband die de taal de taal vormt die door die machine bepaalt wordt. Een enumeratormachine stopt niet altijd of stopt niet altijd bij het uitschrijven van een individuele string.

\begin{bewijs}{We bewijzen dat een taal die door een enumerator bepaald wordt, herkenbaar is.}
  \input{bewijzen/enumrecog}
\end{bewijs}

\begin{bewijs}{We bewijzen dat elke herkenbare taal door een enumerator\\ge\"enumereerd wordt.}
  \input{bewijzen/recogenum}
\end{bewijs}

\subsection{Beslisbare talen}

\begin{bewijs}{We bewijzen dat $A_{DFA}$ beslisbaar is.}
  Voor $A_{DFA} = \{\langle D,s \rangle | D \text{ is een DFA en } D \text{ accepteert } s\}$ construeren we een beslisser $B$ als volgt:
 
  $B$ krijgt een input $\langle D,s \rangle$. $B$ simuleert de uitvoering van $D$ op $S$. Als $D$ $S$ accepteert, dan accepteert $B$ de invoer. Als $D$ $S$ verwerpt, dan verwerpt $B$ de invoer. Een DFA stopt altijd, dus is $B$ een beslisser voor $A_{DFA}$.
\end{bewijs}

\begin{bewijs}{We bewijzen dat $A_{NFA}$ beslisbaar is.}
  Voor $A_{NFA} = \{\langle N,s \rangle | N \text{ is een NFA en } N \text{ accepteert } s\}$ construeren we een beslisser $B$ als volgt:
 
 $B$ krijgt een input $\langle N,s \rangle$. De NFA $N$ wordt omgezet naar een DFA met algoritme \ref{alg:nfadfa}. Nu kunnen we een beslisser $B_D$ construeren voor die DFA en die laten lopen op $s$. $B$ geeft de uitvoer van $B_D$ terug.
\end{bewijs}

\begin{bewijs}{We bewijzen dat $A_{RegExp}$ beslisbaar is.}
  Voor $A_{RegExp} = \{\langle RE,s \rangle | RE \text{ is een reguliere expressie en } RE \text{ accepteert } s\}$ construeren we een beslisser $B$ als volgt:
 
 $B$ krijgt een input $\langle RE,s \rangle$. De reguliere expressie $RE$ wordt omgezet naar een NFA. Nu kunnen we een beslisser $B_N$ construeren voor die NFA en die laten lopen op $s$. $B$ geeft de uitvoer van $B_N$ terug.
\end{bewijs}

% TODO: E_DFA is beslisbaar
% TODO: EQ_DFA is beslisbaar
% TODO: A_CFG is beslisbaar
% TODO: E_CFG is beslisbaar
% TODO: ES_CFG is beslisbaar
% TODO: Elke CFL is beslisbaar
% TODO: REGULAR_TM is niet beslisbaar: $REGULAR_{TM} = \{\langle M \rangle | M \text{ is een Turingmachine en } L_M \text{ is een reguliere taal}\}$
% TODO: EQ_TM is niet beslisbaar
% TODO: ALL_CFG is niet beslisbaar

\subsubsection{Overzicht}
De onderstaande tabel geeft voor heel wat talen weer of ze herkenbaar en beslisbaar zijn:\\[.2cm]
\def\tabularxcolumn#1{m{#1}}
\begin{tabularx}{\textwidth}{c|c|c|X}
  \textbf{Taal} & \textbf{H} & \textbf{B} & \textbf{Beschrijving} \\ \hline
  $A_{DFA}$ & \cmark & \cmark & De taal met alle DFA's die een bepaalde string accepteren.\\ \hline
  $E_{DFA}$ & \cmark & \cmark & De taal met alle DFA's die de lege taal bepalen.\\ \hline
  $EQ_{DFA}$ & \cmark & \cmark & De taal met alle koppels van equivalente DFA's.\\ \hline
  $A_{NFA}$ & \cmark & \cmark & De taal met alle NFA's die een bepaalde string accepteren.\\ \hline
  $A_{RegEx}$ & \cmark & \cmark & De taal met alle reguliere expressies die een bepaalde string accepteren.\\ \hline
  $A_{CFG}$ & \cmark & \cmark & De taal met alle CFG's die een bepaalde string accepteren.\\ \hline
  $E_{CFG}$ & \cmark & \cmark & De taal met alle CFG's die de lege taal bepalen.\\ \hline
  $ES_{CFG}$ & \cmark & \cmark & De taal met alle CFG's die de lege string genereren.\\ \hline
  $L_{CFG}$ & \cmark & \cmark & Een contextvrije taal bepaald door een CFG.\\ \hline
  $ALL_{CFG}$ & \cmark & \xmark & De taal met alle CFG's die de taal $\sstar$ bepalen.\\ \hline
  $A_{LBA}$ & \cmark & \cmark & De taal met alle LBA's die een bepaalde string accepteren.\\ \hline
  $E_{LBA}$ & \cmark & \xmark & De taal met alle LBA's die de lege taal bepalen.\\ \hline
  $\atm$ & \cmark & \xmark & De taal met alle Turingmachines die voor een bepaalde string, die string accepteren.\\ \hline
  $\htm$ & \cmark & \xmark & De taal met alle Turingmachines die voor een bepaalde string, die string accepteren of verwerpen.\\ \hline
  $\etm$ & \cmark & \xmark & De taal met alle Turingmachines die de lege taal bepalen.\\ \hline
  $\eqtm$ & \xmark & \xmark & De taal met alle koppels van equivalente Turingmachines.\\ \hline
  $REGULAR_{TM}$ & \cmark & \xmark & De taal met alle Turingmachines die een reguliere taal bepalen.\\
\end{tabularx}
\def\tabularxcolumn#1{p{#1}}

% TODO: Aftelbaarheid

\subsection{Stelling van Rice}

Een eigenschap $P$ van Turingmachines verdeelt die in twee verzamelingen. De machines met die eigenschap $Pos_P = \{M|P(M)=true\}$ en de machines zonder die eigenschap $Neg_P = \{M|P(M)=false\}$. Samen vormen ze een partitie $\{Pos_P, Neg_P\}$ van de verzameling van alle Turingmachines.

\begin{definitie}{Niet-triviale eigenschap}
  Een eigenschap $P$ is niet triviaal indien $Pos_P \neq \emptyset$ en $Neg_P \neq \emptyset$.
\end{definitie}

\begin{definitie}{Taal-invariante eigenschap}
  Een eigenschap $P$ is taal-invariant als alle machines die dezelfde taal bepalen ook die eigenschap gemeenschappelijk hebben (of geen enkel van die machines die eigenschap heeft).
  \begin{equation*}
  L_{M_1} = L_{M_2} \Rightarrow P(M_1) = P(M_2)
  \end{equation*}
\end{definitie}

\begin{definitie}{Eerste stelling van Rice}
  Voor elke niet-triviale, taal-invariante eigenschap $P$ geldt dat $Pos_P$ niet beslisbaar is. (Ook $Neg_P$ is niet beslisbaar, maar dat volgt uit $Neg_P = \overline{Pos_P}$.)
\end{definitie}

\begin{bewijs}{We bewijzen de eerste stelling van Rice}
  Stel dat $M_\emptyset$ die de lege taal bepaalt, een eigenschap $P$ niet heeft. Omdat $P$ niet-triviaal is, moet er een machine $X$ bestaan die de taal $L_X$ bepaalt en de eigenschap $P$ wel heeft.

  Stel dat er een beslisser $B$ bestaan voor $Pos_P$, dan kunnen we een beslisser $A$ voor $A_{TM}$ construeren. Voor een gegeven invoer $\langle M,s \rangle$ construeren we een hulpmachine $H_{M,s}$ waarvoor geldt
  \begin{itemize}
  \item $H_{M,s}$ laat $M$ lopen op $s$.
  \item Als $M$ $s$ accepteert, dan laat $H_{M,s}$ $X$ lopen op een invoer $x$ en accepteert indien $X$ $x$ accepteert.
  \end{itemize}
  
  We kunnen zeggen dat voor $H_{M,s}$ geldt dat het de taal $L_X$ bepaalt indien $M$ $s$ accepteert en de lege taal bepaalt indien $M$ $s$ niet accepteert. Dat wilt zeggen dat $H_{M,s}$ de eigenschap $P$ heeft indien $M$ $s$ accepteert en de eigenschap $P$ niet heeft indien $M$ $s$ niet accepteert.
  
  Bijgevolg kunnen we zeggen dat $A$ een invoer $\langle M,s \rangle$ accepteert als $B$ $H_{M,s}$ accepteert en de invoer verwerpt als $B$ $H_{M,s}$ verwerpt. Dus $A$ is een beslisser voor $\atm$, wat niet mogelijk is. Daarom kan de beslisser $B$ voor $Pos_P$ ook niet bestaan.
  
  We zeggen dat $\atm$ reduceerbaar is naar $Pos_P$.
  
  Als $M_\emptyset$ de eigenschap $P$ wel heeft, kunnen we het bewijs uitvoeren voor $\overline{P}$. Omdat we dan bewijzen dat $Pos_{\overline{P}} = Neg_P$ onbeslisbaar is, weten we dat ook $Pos_P = \overline{Neg_P}$ onbeslisbaar is.
\end{bewijs}

% TODO: Tweede stelling van Rice?
% TODO: Post Correspondence Problem

\subsection{Reductie}

\begin{definitie}{Turing-berekenbare functie}
  Een functie $f$ is Turing-berkenbaar als er een Turingmachine bestaat die bij een invoer van $s$, stopt met $f(s)$ op de band.
\end{definitie}

\begin{definitie}{Reductie van talen}
  Een taal $L_1$ over $\Sigma_1$ kan gereduceerd worden naar een taal $L_2$ over $\Sigma_2$ als er een afbeelding \bm{$f: \sstar_1 \rightarrow \sstar_2$} bestaat zodanig dat $f(L_1) \subseteq L_2$ en $f(\overline{L_1}) \subseteq \overline{L_2}$ met $f$ een Turing-berkenbare functie.
  \begin{equation*}
  L_1 \leq_m L_2
  \end{equation*}
\end{definitie}

\begin{itemize}
\item Als $L_1 \leq_m L_2$ en $L_1$ is niet beslisbaar, dan is $L_2$ niet beslisbaar.
\item Als $L_1 \leq_m L_2$ en $L_2$ is beslisbaar, dan is $L_1$ beslisbaar.
\item Als $L_1 \leq_m L_2$ en $L_1$ is niet herkenbaar, dan is $L_2$ niet herkenbaar.
\item Als $L_1 \leq_m L_2$ en $L_2$ is herkenbaar, dan is $L_1$ herkenbaar.
\end{itemize}

We kunnen bewijzen dat $\etm$ niet beslisbaar is met de functie $f$ die  $E(\langle M \rangle)$ afbeeldt op $EQ(\langle M,M_\emptyset \rangle)$. We noteren $\etm \leq_m \eqtm$.

% TODO: Bewijs dat als L1 naar L2 reduceert, dat \overline{L1} ook naar \overline{L2} reduceert.
% TODO: Bewijs EQ_TM is net herkenbaar en niet co-herkenbaar

\subsection{Orakelmachines}

\begin{definitie}{Orakelmachine}
  Een orakelmachine is een Turingmachine die vragen kan stellen aan een orakel over een taal/probleem. Het orakel kan in een eindig (klein) aantal stappen een antwoord teruggeven aan de orakelmachine.
\end{definitie}

We kunnen een orakelmachine $\oatm$ bouwen die $\atm$ beslist. De verzameling van orakelmachines met $\oatm$ is strikt sterker van de verzameling van de Turingmachines omdat die meer talen beslist/herkent. Aangezien dat heel wat talen niet beslisbaar (of zelfs herkenbaar) zijn omdat $\atm$ niet beslisbaar is.

\begin{bewijs}{We bewijzen dat er een $\oatm$ bestaat die $\etm$ beslist.}
  We construeren een Orakelmachine $\oatm$. Bij input $\langle M \rangle$ doet $\oatm$:
  \begin{itemize}
  \item Construeer een Turingmachine $P$ die bij input $w$:
  \begin{itemize}
  \item $M$ laat lopen op alle strings van $\sstar$.
  \item Als $M$ eender welke string van $\sstar$ accepteert, dan accepteert $P$ de input $w$. ($P$ accepteert voor eendere welke $w$ zo lang dat $M$ minstens \'e\'en string accepteert en dus niet de lege taal bepaalt.)
  \end{itemize}
  \item $\oatm$ vraagt aan het orakel of $\langle P,w \rangle \in \atm$.
  \item Als het orakel ``ja'' antwoordt, dan verwerpt $\oatm$ de invoer, omdat $M$ niet de lege taal bepaalt. Anders accepteert het de invoer.
  \end{itemize}
  
  $\oatm$ is een beslisser voor de taal $\etm$.
\end{bewijs}

\begin{definitie}{Turingreduceerbaarheid}
  Een taal $A$ is Turingeduceerbaar naar een taal $B$ indien er een orakelmachine $O^B$ bestaat die $A$ beslist. We zeggen dat $A$ beslisbaar is t.o.v. $B$.
  \begin{equation*}
  A \leq_T B
  \end{equation*}
\end{definitie}

\begin{itemize}
\item Indien $A \leq_T B$ en $B$ is beslisbaar, dan is $A$ beslisbaar.
\item $\leq_m$ is fijner dan $\leq_T$, dus $A \leq_m B \rightarrow A \leq_T B$
\end{itemize}

De taal $\{O|O\text{ is een orakelmachine met een orakel voor }\atm\}$ kan niet elke taal beslissen want die verzameling is aftelbaar en de verzameling van alle talen $\l_\Sigma$ is niet-aftelbaar. Dus er bestaat minstens \'e\'en taal X die niet beslisbaar is met de hulp van een orakel voor $\atm$.

% TODO: Turingberekenbare functies!!
% TODO: Bezige bever en stijgende functies

\newpage\section{$\Lambda$-calculus}

$\lambda$-calculus is een herschijfsysteem dat de basis vormt voor functionele programmeertalen zoals Haskell.

\begin{definitie}{$\lambda$-expressie}
  Een $\lambda$-expressie $<exp>$ kan \'e\'en van de volgende vormen aannemen:
  \begin{itemize}
  \item $<const>$: Een constante.
  \item $<var>$: Een variabele.
  \item $<exp> <exp>$: De toepassing van een functie op een argument.
  \item $\lambda<var>. <exp>$: Een $\lambda$-abstractie die een variabele bindt.
  \item $(<exp>)$: Een expressie omsloten door haakjes.
  \end{itemize}
\end{definitie}

\begin{definitie}{Currying}
  Het toepassen van een functie in een $\lambda$-expressie kan steeds maar op \'e\'en argument. Currying is een techniek die wordt toegepast om een functie te herschrijven naar een opeenvolging van functietoepassingen op telkens \'e\'en element.
\end{definitie}

Een simpel voorbeeld van currying is de functie $+$ voor natuurlijke getallen:\\
\bm{$+: \nat \times \nat \rightarrow \nat$}\\
$(+\ a\ b)$

Deze functie wordt d.m.v. currying vertaalt naar:\\
\bm{$+: \nat \rightarrow (\nat \rightarrow \nat)$}\\
$((+\ a)\ b)$

Bij bovenstaande functie is $(+\ a)$ een functie die een getal $i$ afbeeldt op $a + i$.

\begin{definitie}{Deel-expressie}
  Een deel-expressie van een $\lambda$-expressie is een geneste $\lambda$-expressie.
\end{definitie}

\begin{definitie}{Redex}
  Een deel-expressie van een $\lambda$-expressie is een redex indien zijn parameters getallen zijn en de expressie reduceerbaar is.
\end{definitie}

\begin{definitie}{Reductie}
  Een reductie is het reduceren van de redex in een $\lambda$-expressie door meestal een functie evaluatie uit te voeren. Gewoonlijk wordt de meest linkse redex eerst gereduceerd.
\end{definitie}

\begin{definitie}{Normaalvorm}
  Een $\lambda$-expressie in normaalvorm is een expressie die geen redex bevat. Niet elke $\lambda$-expressie heeft een normaalvorm. Indien er een equivalente normaalvorm bestaat voor een expressie, dan bestaat er een rij reductieregels die die expressie omvormen tot de normaalvorm.
\end{definitie}

\begin{definitie}{$\lambda$-abstractie}
  Een $\lambda$-abstractie is een functie definitie van de vorm:
  \begin{itemize}
  \item $\lambda$
  \item $<var>$: \'E\'en variabele.
  \item $.$: Dit punt scheidt de definitie van de variabele van het lichaam van de functie.
  \item $<exp>$: De expressie die aangeeft hoe de functie moet berekent worden.
  \end{itemize}
\end{definitie}

Een alternatieve notatie voor een $\lambda$-expressie met twee (of meerdere) variabelen bestaat ook. Een voorbeeld: $(\lambda x\ y.(+\ x\ y)) = (\lambda x.(\lambda y.(+\ x\ y)))$

\begin{definitie}{Vrije/gebonden variabele}
  Een variabele in een $\lambda$-expressie is gebonden indien die expressie genest is in een $\lambda$-abstractie die de variabele met die naam definieert. Een variabele die vrij is, is niet gedefinieerd. We zeggen dat een variabele $x$ vrij is in een expressie $E$ indien:
  \begin{itemize}
  \item $E == x$
  \item $E == (A\ B)$ en er is een vrij voorkomen van $x$ in $A$ of $B$.
  \item $E == (\lambda y. A)$ en $x \neq y$ en er is een vrij voorkomen van $x$ in $A$
  \end{itemize}
\end{definitie}

Een variabele gedefinieerd in een $\lambda$-abstractie wordt gebonden aan alle vrije voorkomens van die variabele in de deelexpressie (en verder geneste deelexpressies) van die $\lambda$-abstractie.

\subsection{Herschrijfregels van $\lambda$-calculus}

Elke conversie regel is een samenstelling van een reductieregel ($\longrightarrow$) en een abstractieregel ($\longleftarrow$) die een equivalentie beschrijft. Een abstractie is de inverse operatie van een reductie. Twee expressies $A$ en $B$ zij equivalent onder een rij conversie als $\stackrel{*}{\longleftrightarrow}$. Indien er een rij reducties bestaat die $A$ naar $B$ reduceert, schrijven we $\stackrel{*}{\longrightarrow}$.

\begin{definitie}{$\beta$-reductie}
  $\beta$-reductie ($\stackrel{\beta}{\longrightarrow}$) is een syntactische herschrijfregel die een $\lambda$-abstractie herschrijft naar het lichaam van die $\lambda$-abstractie met de formele parameter vervangen door het argument. Deze reductie wordt gebruikt bij een functietoepassing.
\end{definitie}

Een voorbeeld van $\beta$-reductie: $(\lambda x.\ +\ x\ x)\ 5 \stackrel{\beta}{\longrightarrow} +\ 5\ 5$.

\begin{definitie}{$\beta$-abstractie}
  $\beta$-abstractie ($\stackrel{\beta}{\longleftarrow}$) is een syntactische herschrijfregel die de inverse operatie van een $\beta$-reductie uitvoert door een expressie in een $\lambda$-abstractie te plaatsen en \'e\'en (of meerdere gelijke) deelexpressies te vervangen door de formele parameter, zodanig dat de expressie een argument wordt.
\end{definitie}

Een voorbeeld van $\beta$-abstractie: $+\ 5\ 5 \stackrel{\beta}{\longrightarrow} (\lambda x.\ +\ x\ x)\ 5$.

\begin{definitie}{$\alpha$-reductie of $\alpha$-abstractie}
  $\alpha$-reductie ($\stackrel{\alpha}{\longrightarrow}$) is een herschrijfregel (hernoemingsregel) die alle vrije voorkomens van de formele parameter in het lichaam van een $\lambda$-abstractie hernoemt. De $\alpha$-abstractie operatie is identiek aan $\alpha$-reductie ($\stackrel{\alpha}{\longleftarrow}$), dus kunnen voor beiden de term $\alpha$-conversie ($\stackrel{\alpha}{\longleftrightarrow}$) gebruiken.
\end{definitie}

Een voorbeeld van $\alpha$-conversie: $(\lambda x.\ +\ x\ x) \stackrel{\alpha}{\longleftrightarrow} (\lambda y.\ +\ y\ y)$.

\begin{definitie}{$\eta$-reductie of $\eta$-abstractie}
  $\eta$-reductie ($\stackrel{\eta}{\longrightarrow}$) is een herschrijfregel die een functietoepassing waaraan een $\lambda$-abstractie slechts een parameter doorgeeft herschrijft naar zijn equivalent zonder de $\lambda$-abstractie. De $\eta$-abstractie operatie is de inverse van $\eta$-reductie ($\stackrel{\eta}{\longleftarrow}$). We spreken over een regel die equivalentie aantoont dus wordt meestal $\eta$-conversie ($\stackrel{\eta}{\longleftrightarrow}$) gebruikt.
\end{definitie}

Een voorbeeld van $\eta$-conversie: $(\lambda x.\ F\ x) \stackrel{\eta}{\longleftrightarrow} F$.

% TODO: Name capture problem

\begin{definitie}{$\delta$-reductie of $\delta$-abstractie}
  $\delta$-reductie ($\stackrel{\delta}{\longrightarrow}$) is een herschrijfregel die functies intern aan de taal toepast op een argument in de expressie. De $\delta$-abstractie operatie is de inverse van $\delta$-reductie die een expressie vervangt door een expressie en een interne operatie die samen equivalent zijn aan de originele expressie.
\end{definitie}

Een voorbeeld van $\delta$-conversie: $+\ 5\ 5 \stackrel{\delta}{\longleftrightarrow} 10$.

% TODO: Church numerals

\begin{definitie}{Oneindige lus}
  Een oneindige lus is een expressie die nooit in normaalvorm kan gebracht worden. Een oneindige lus kan zeer makkelijk gemodelleerd worden als $(\lambda x. x\ x)(\lambda x. x\ x)$ omdat bij elke reductie terug dezelfde expressie verkregen wordt.
\end{definitie}

\subsection{Reductie in normaalorde}

\begin{definitie}{Church-Rosser I (CR1)}
  Church-Rosser I verwijst naar de eerste stelling van Church en Rosser. Die stelling zegt dat indien $E_1 \stackrel{*}{\longleftrightarrow} E_2$ geldt, dat er een expressie $E$ moet bestaan in normaalvorm zodanig dat $E_1 \stackrel{*}{\longrightarrow} E$ en $E_2 \stackrel{*}{\longrightarrow} E$.
\end{definitie}

\begin{bewijs}{We bewijzen de uniciteit van de normaalvorm.}
  Stel dat $E \stackrel{*}{\longleftrightarrow} E_1$ en $E \stackrel{*}{\longleftrightarrow} E_2$ gelden, waarbij dat $E_1$ en $E_2$ in normaalvorm staan. Dan moet gelden dat $E_1 \stackrel{*}{\longleftrightarrow} E_2$. Volgend CR1 moet dan gelden dat er een normaalvorm $F$ bestaat zodanig dat $E_1 \stackrel{*}{\longleftrightarrow} F$ en $E_2 \stackrel{*}{\longleftrightarrow} F$. Omdat $E_1$ en $E_2$ reeds in normaalvorm staan, zijn er in geen van beiden expressies nog redexen die gereduceerd kunnen worden, dus concluderen we dat (eventuaal onder $\alpha$-conversie) $E_1 = F = E_2$.
\end{bewijs}

\begin{definitie}{Reductie in normaalorde}
Bij reductie in normaalorde wordt steeds de meest linkse buitenste redex eerst gereduceerd.
\end{definitie}

Reductie in normaalorde garandeert dat een normaalvorm gevonden wordt (indien mogelijk), maar is niet noodzakelijk optimaal. Het is mogelijk dat een andere reductieorde een reductierij oplevert met minder stappen. Een voorbeeld daarvan is de ``call-by-value'' techniek, waarbij eerst een argument voor een functie wordt gereduceerd. Een expressie die wordt doorgegeven als argument voor reductie, kan mogelijk meerdere keren ge\"evalueerd worden.

\begin{definitie}{Church-Rosser II (CR2)}
  Church-Rosser II verwijst naar de tweede stelling van Church en Rosser. Die stelling zegt dat indien $E \stackrel{*}{\longleftrightarrow} N$  bestaat met $N$ in normaalvorm, dat er een rij reducties moet bestaan in normaal orde van $E$ naar $N$.
\end{definitie}

\begin{definitie}{Turing-equivalente $\lambda$-calculus}
  \label{def:tmlambda}
  $\lambda$-calculus kan alle Turing-berekenbare functies voorstellen, omdat:
  \begin{itemize}
  \item De reductie naar normaalvorm van een expressie heeft steeds slechts \'e\'en resultaat als die reductie een eindig aantal stappen heeft, namelijk de redex, ongeacht de reductieorde. We weten dat een Turingmachine slechts \'e\'en taal bepaalt.
  \item Wanneer een expressie niet naar normaalvorm gereduceerd kan worden, is er een lus waardoor de reductie nooit eindigt. Ook de uitvoering van een Turingmachine stopt niet altijd.
  \end{itemize}
\end{definitie}

Uit definitie \ref{def:tmlambda} volgt dat elke Turingmachine in $\lambda$-calculus kan worden voorgesteld. $\lambda$-calculus en Turingmachine zijn equivalent, dus ook elke $\lambda$-calculus expressie moet door een Turingmachine ge\"evalueerd kunnen worden.

\subsection{Recursieve functies}

Indien een $\lambda$-calculus toelaat om functies bij naam te defini\"eren of naar zichzelf te laten verwijzen, is het mogelijk om recursieve functies op te stellen. Dat is echter ook mogelijk in pure $\lambda$-calculus met een vastpuntcombinator.

\begin{definitie}{Vastpuntcombinator}
  Een vastpuntcombinator (FPC) is een functie $Y$ die voldoet aan
  \begin{equation*}
  F: Y\ F = F\ (Y\ F)
  \end{equation*}
  De vastpuntcombinator van Curry wordt het vaak gebruikt en is gedefinieerd als
  \begin{equation*}
  \lambda f.\ (\lambda x.\ f\ (x\ x))\ (\lambda x.\ f\ (x\ x))
  \end{equation*}
\end{definitie}

% TODO: Programmeertalen

\include{voorbeelden}
\include{examenvragen}

\end{document}
